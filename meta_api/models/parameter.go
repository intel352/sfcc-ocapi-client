// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Parameter Object for describing an HTTP method parameter.
// swagger:model parameter
type Parameter struct {

	// Parameter description.
	Description string `json:"description,omitempty"`

	// Output format information.
	// Enum: [int32 int64 float double byte date date-time time text email html password money site-specific localized]
	Format string `json:"format,omitempty"`

	// Type of the parameter.
	// Enum: [header query path body]
	In string `json:"in,omitempty"`

	// Parameter type description for type 'array'.
	Items *Property `json:"items,omitempty"`

	// max length
	MaxLength int32 `json:"maxLength,omitempty"`

	// Maximum value of the parameter.
	Maximum float64 `json:"maximum,omitempty"`

	// min length
	MinLength int32 `json:"minLength,omitempty"`

	// Minimum value of the parameter.
	Minimum float64 `json:"minimum,omitempty"`

	// Parameter name.
	Name string `json:"name,omitempty"`

	// Regular expression to limit string value.
	Pattern string `json:"pattern,omitempty"`

	// True, if parameter is mandatory.
	Required bool `json:"required,omitempty"`

	// Schema to refer to another document as parameter type.
	Schema *Schema `json:"schema,omitempty"`

	// Data type, obsolete if schema is set.
	// Enum: [integer number string boolean array object]
	Type string `json:"type,omitempty"`
}

// Validate validates this parameter
func (m *Parameter) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSchema(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var parameterTypeFormatPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["int32","int64","float","double","byte","date","date-time","time","text","email","html","password","money","site-specific","localized"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		parameterTypeFormatPropEnum = append(parameterTypeFormatPropEnum, v)
	}
}

const (

	// ParameterFormatInt32 captures enum value "int32"
	ParameterFormatInt32 string = "int32"

	// ParameterFormatInt64 captures enum value "int64"
	ParameterFormatInt64 string = "int64"

	// ParameterFormatFloat captures enum value "float"
	ParameterFormatFloat string = "float"

	// ParameterFormatDouble captures enum value "double"
	ParameterFormatDouble string = "double"

	// ParameterFormatByte captures enum value "byte"
	ParameterFormatByte string = "byte"

	// ParameterFormatDate captures enum value "date"
	ParameterFormatDate string = "date"

	// ParameterFormatDateTime captures enum value "date-time"
	ParameterFormatDateTime string = "date-time"

	// ParameterFormatTime captures enum value "time"
	ParameterFormatTime string = "time"

	// ParameterFormatText captures enum value "text"
	ParameterFormatText string = "text"

	// ParameterFormatEmail captures enum value "email"
	ParameterFormatEmail string = "email"

	// ParameterFormatHTML captures enum value "html"
	ParameterFormatHTML string = "html"

	// ParameterFormatPassword captures enum value "password"
	ParameterFormatPassword string = "password"

	// ParameterFormatMoney captures enum value "money"
	ParameterFormatMoney string = "money"

	// ParameterFormatSiteSpecific captures enum value "site-specific"
	ParameterFormatSiteSpecific string = "site-specific"

	// ParameterFormatLocalized captures enum value "localized"
	ParameterFormatLocalized string = "localized"
)

// prop value enum
func (m *Parameter) validateFormatEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, parameterTypeFormatPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Parameter) validateFormat(formats strfmt.Registry) error {

	if swag.IsZero(m.Format) { // not required
		return nil
	}

	// value enum
	if err := m.validateFormatEnum("format", "body", m.Format); err != nil {
		return err
	}

	return nil
}

var parameterTypeInPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["header","query","path","body"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		parameterTypeInPropEnum = append(parameterTypeInPropEnum, v)
	}
}

const (

	// ParameterInHeader captures enum value "header"
	ParameterInHeader string = "header"

	// ParameterInQuery captures enum value "query"
	ParameterInQuery string = "query"

	// ParameterInPath captures enum value "path"
	ParameterInPath string = "path"

	// ParameterInBody captures enum value "body"
	ParameterInBody string = "body"
)

// prop value enum
func (m *Parameter) validateInEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, parameterTypeInPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Parameter) validateIn(formats strfmt.Registry) error {

	if swag.IsZero(m.In) { // not required
		return nil
	}

	// value enum
	if err := m.validateInEnum("in", "body", m.In); err != nil {
		return err
	}

	return nil
}

func (m *Parameter) validateItems(formats strfmt.Registry) error {

	if swag.IsZero(m.Items) { // not required
		return nil
	}

	if m.Items != nil {
		if err := m.Items.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("items")
			}
			return err
		}
	}

	return nil
}

func (m *Parameter) validateSchema(formats strfmt.Registry) error {

	if swag.IsZero(m.Schema) { // not required
		return nil
	}

	if m.Schema != nil {
		if err := m.Schema.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("schema")
			}
			return err
		}
	}

	return nil
}

var parameterTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["integer","number","string","boolean","array","object"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		parameterTypeTypePropEnum = append(parameterTypeTypePropEnum, v)
	}
}

const (

	// ParameterTypeInteger captures enum value "integer"
	ParameterTypeInteger string = "integer"

	// ParameterTypeNumber captures enum value "number"
	ParameterTypeNumber string = "number"

	// ParameterTypeString captures enum value "string"
	ParameterTypeString string = "string"

	// ParameterTypeBoolean captures enum value "boolean"
	ParameterTypeBoolean string = "boolean"

	// ParameterTypeArray captures enum value "array"
	ParameterTypeArray string = "array"

	// ParameterTypeObject captures enum value "object"
	ParameterTypeObject string = "object"
)

// prop value enum
func (m *Parameter) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, parameterTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Parameter) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Parameter) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Parameter) UnmarshalBinary(b []byte) error {
	var res Parameter
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
