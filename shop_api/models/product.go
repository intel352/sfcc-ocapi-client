// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Product Document representing a product.
// swagger:model product
type Product struct {

	// The product's brand.
	Brand string `json:"brand,omitempty"`

	// The array of all bundled products of this product.
	BundledProducts []*BundledProduct `json:"bundled_products"`

	// Signals if there are inventory lists for brick-and-mortar stores associated with this product.
	CAvailableForInStorePickup bool `json:"c_availableForInStorePickup,omitempty"`

	// c battery life
	CBatteryLife string `json:"c_batteryLife,omitempty"`

	// c battery type
	CBatteryType string `json:"c_batteryType,omitempty"`

	// Type of Boot for search refinement.
	CBootType []string `json:"c_bootType"`

	// Bottom type for search refinement
	CBottomType []string `json:"c_bottomType"`

	// Product color used for variation attribute
	CColor string `json:"c_color,omitempty"`

	// c console warranty
	CConsoleWarranty string `json:"c_consoleWarranty,omitempty"`

	// Use this attribute to apply custom styles for this product.
	CCustomCSSFile string `json:"c_customCSSFile,omitempty"`

	// c digital camera features
	CDigitalCameraFeatures []string `json:"c_digitalCameraFeatures"`

	// c digital camera pixels
	CDigitalCameraPixels string `json:"c_digitalCameraPixels,omitempty"`

	// c digital camera type
	CDigitalCameraType string `json:"c_digitalCameraType,omitempty"`

	// c digital camera warranty
	CDigitalCameraWarranty string `json:"c_digitalCameraWarranty,omitempty"`

	// c dim depth
	CDimDepth string `json:"c_dimDepth,omitempty"`

	// c dim height
	CDimHeight string `json:"c_dimHeight,omitempty"`

	// c dim weight
	CDimWeight string `json:"c_dimWeight,omitempty"`

	// c dim width
	CDimWidth string `json:"c_dimWidth,omitempty"`

	// c display size
	CDisplaySize string `json:"c_displaySize,omitempty"`

	// c game genre
	CGameGenre []string `json:"c_gameGenre"`

	// c game rating
	CGameRating string `json:"c_gameRating,omitempty"`

	// c game system type
	CGameSystemType string `json:"c_gameSystemType,omitempty"`

	// c gps features
	CGpsFeatures []string `json:"c_gpsFeatures"`

	// c gps type
	CGpsType []string `json:"c_gpsType"`

	// c gps warranty
	CGpsWarranty string `json:"c_gpsWarranty,omitempty"`

	// c image aspect ratio
	CImageAspectRatio string `json:"c_imageAspectRatio,omitempty"`

	// c is new
	CIsNew bool `json:"c_isNew,omitempty"`

	// This indiciates if the product is a new arrival.
	CIsNewtest bool `json:"c_isNewtest,omitempty"`

	// This is the help text. It is used for sorting rules.
	CIsSale bool `json:"c_isSale,omitempty"`

	// Kids Age used for search refinements
	// Enum: [0010 0020 0030 0040 0050 0060 0070]
	CKidsAge string `json:"c_kidsAge,omitempty"`

	// This attribute is used for mens and womens pants lengths.
	CLength string `json:"c_length,omitempty"`

	// c lens aperture
	CLensAperture string `json:"c_lensAperture,omitempty"`

	// c material test
	CMaterialTest []string `json:"c_materialTest"`

	// Media Format
	CMediaFormat []string `json:"c_mediaFormat"`

	// Memory Size
	CMemorySize string `json:"c_memorySize,omitempty"`

	// c memory type
	CMemoryType []string `json:"c_memoryType"`

	// c music storage
	CMusicStorage string `json:"c_musicStorage,omitempty"`

	// c optical zoom
	COpticalZoom string `json:"c_opticalZoom,omitempty"`

	// Type of Outerwear for search refinement
	// Enum: [0010 0020 0030 0040 0050 0060 0070 0080]
	COuterwearType string `json:"c_outerwearType,omitempty"`

	// c portable audio type
	CPortableAudioType []string `json:"c_portableAudioType"`

	// c refinement color
	// Enum: [black blue green red orange pink purple white yellow grey beige miscellaneous brown navy]
	CRefinementColor string `json:"c_refinementColor,omitempty"`

	// c resolution
	CResolution string `json:"c_resolution,omitempty"`

	// Type of Sandal for search refinement
	// Enum: [0010 0020 0030]
	CSandalType string `json:"c_sandalType,omitempty"`

	// test attribute
	CSheets []string `json:"c_sheets"`

	// Type of Shoe for search refinements
	// Enum: [0010 0020 0030 0040 0050 0060 0070 0080 0090 0100 0110]
	CShoeType string `json:"c_shoeType,omitempty"`

	// This attribute is used for all footwear, apparel and accessory sizing for men, women and kids products.
	CSize string `json:"c_size,omitempty"`

	// c skin concern
	CSkinConcern []string `json:"c_skinConcern"`

	// c style number
	CStyleNumber string `json:"c_styleNumber,omitempty"`

	// c tab description
	CTabDescription string `json:"c_tabDescription,omitempty"`

	// c tab details
	CTabDetails string `json:"c_tabDetails,omitempty"`

	// c test
	CTest string `json:"c_test,omitempty"`

	// Type of tops in clothing
	CTopType string `json:"c_topType,omitempty"`

	// c tv signal format
	CTvSignalFormat string `json:"c_tvSignalFormat,omitempty"`

	// c tv size
	CTvSize string `json:"c_tvSize,omitempty"`

	// c tv type
	// Enum: [0010 0020 0030 0040]
	CTvType string `json:"c_tvType,omitempty"`

	// c tv warranty
	CTvWarranty string `json:"c_tvWarranty,omitempty"`

	// c video storage
	CVideoStorage string `json:"c_videoStorage,omitempty"`

	// Attribute used for apparel waist sizing.
	CWaist string `json:"c_waist,omitempty"`

	// This attribute is used for shoe widths for mens, womens and kids.
	CWidth string `json:"c_width,omitempty"`

	// The ISO 4217 mnemonic code of the currency.
	Currency string `json:"currency,omitempty"`

	// The European Article Number.
	Ean string `json:"ean,omitempty"`

	// fetch date
	FetchDate int32 `json:"fetch_date,omitempty"`

	// The id (SKU) of the product.
	// Required: true
	// Max Length: 100
	// Min Length: 1
	ID *string `json:"id"`

	// The array of product image groups.
	ImageGroups []*ImageGroup `json:"image_groups"`

	// The array of product inventories explicitly requested via 'inventory_ids' query parameter. This property
	//  is only returned in context of the 'availability' expansion.
	Inventories []*Inventory `json:"inventories"`

	// The site default inventory information. This property is only
	//  returned in context of the 'availability' expansion.
	Inventory *Inventory `json:"inventory,omitempty"`

	// The localized product long description.
	LongDescription string `json:"long_description,omitempty"`

	// The products manufacturer name.
	ManufacturerName string `json:"manufacturer_name,omitempty"`

	// The products manufacturer sku.
	ManufacturerSku string `json:"manufacturer_sku,omitempty"`

	// The master product information. Only for types master, variation group and variant.
	Master *Master `json:"master,omitempty"`

	// The minimum order quantity for this product.
	MinOrderQuantity float64 `json:"min_order_quantity,omitempty"`

	// The localized product name.
	Name string `json:"name,omitempty"`

	// The array of product options. This array can be empty. Only for type option.
	Options []*Option `json:"options"`

	// The localized products page description.
	PageDescription string `json:"page_description,omitempty"`

	// The localized products page description.
	PageKeywords string `json:"page_keywords,omitempty"`

	// The localized products page title.
	PageTitle string `json:"page_title,omitempty"`

	// The sales price of the product. In case of complex products like master or set this is the minimum price of
	//  related child products.
	Price float64 `json:"price,omitempty"`

	// The maximum sales of related child products in case of complex products like master or set.
	PriceMax float64 `json:"price_max,omitempty"`

	// The prices map with price book ids and their values.
	Prices map[string]float64 `json:"prices,omitempty"`

	// The id of the products primary category.
	PrimaryCategoryID string `json:"primary_category_id,omitempty"`

	// The array of source and target products links information.
	ProductLinks []*ProductLink `json:"product_links"`

	// The array of active customer product promotions for this product. This array can be empty.
	//  Coupon promotions are not returned in this array.
	ProductPromotions []*ProductPromotion `json:"product_promotions"`

	// Returns a list of recommendations.
	Recommendations []*Recommendation `json:"recommendations"`

	// The array of set products of this product.
	SetProducts []*Product `json:"set_products"`

	// The localized product short description.
	ShortDescription string `json:"short_description,omitempty"`

	// The steps in which the order amount of the product can be
	//  increased.
	StepQuantity float64 `json:"step_quantity,omitempty"`

	// The product type information. Can be one or multiple of the following values: item,master,variation_group,variant,bundle,set.
	Type *ProductType `json:"type,omitempty"`

	// The sales unit of the product.
	Unit string `json:"unit,omitempty"`

	// The Universal Product Code.
	Upc string `json:"upc,omitempty"`

	// The time when product is valid from.
	// Format: date-time
	ValidFrom strfmt.DateTime `json:"valid_from,omitempty"`

	// The time when product is valid to.
	// Format: date-time
	ValidTo strfmt.DateTime `json:"valid_to,omitempty"`

	// The array of actual variants. This array can be empty. Only for types master, variation group and variant.
	Variants []*Variant `json:"variants"`

	// Sorted array of variation attributes information. This array can be empty. Only for types master,
	//  variation group and variant.
	VariationAttributes []*VariationAttribute `json:"variation_attributes"`

	// The array of actual variation groups. This array can be empty. Only for types master, variation group and variant.
	VariationGroups []*VariationGroup `json:"variation_groups"`

	// The actual variation attribute id - value pairs. Only for type variant and
	//  variation group.
	VariationValues map[string]string `json:"variation_values,omitempty"`
}

// Validate validates this product
func (m *Product) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBundledProducts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCBootType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCBottomType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCDigitalCameraFeatures(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCGameGenre(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCGpsFeatures(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCGpsType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCKidsAge(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCMaterialTest(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCMediaFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCMemoryType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCOuterwearType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCPortableAudioType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCRefinementColor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCSandalType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCSheets(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCShoeType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCSkinConcern(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCTvType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImageGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInventories(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInventory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaster(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductPromotions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecommendations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSetProducts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidFrom(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidTo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVariants(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVariationAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVariationGroups(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Product) validateBundledProducts(formats strfmt.Registry) error {

	if swag.IsZero(m.BundledProducts) { // not required
		return nil
	}

	for i := 0; i < len(m.BundledProducts); i++ {
		if swag.IsZero(m.BundledProducts[i]) { // not required
			continue
		}

		if m.BundledProducts[i] != nil {
			if err := m.BundledProducts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("bundled_products" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var productCBootTypeItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040","0050","0060","0070"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCBootTypeItemsEnum = append(productCBootTypeItemsEnum, v)
	}
}

func (m *Product) validateCBootTypeItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCBootTypeItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCBootType(formats strfmt.Registry) error {

	if swag.IsZero(m.CBootType) { // not required
		return nil
	}

	for i := 0; i < len(m.CBootType); i++ {

		// value enum
		if err := m.validateCBootTypeItemsEnum("c_bootType"+"."+strconv.Itoa(i), "body", m.CBootType[i]); err != nil {
			return err
		}

	}

	return nil
}

var productCBottomTypeItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040","0050","0060","0070","0080"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCBottomTypeItemsEnum = append(productCBottomTypeItemsEnum, v)
	}
}

func (m *Product) validateCBottomTypeItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCBottomTypeItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCBottomType(formats strfmt.Registry) error {

	if swag.IsZero(m.CBottomType) { // not required
		return nil
	}

	for i := 0; i < len(m.CBottomType); i++ {

		// value enum
		if err := m.validateCBottomTypeItemsEnum("c_bottomType"+"."+strconv.Itoa(i), "body", m.CBottomType[i]); err != nil {
			return err
		}

	}

	return nil
}

var productCDigitalCameraFeaturesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040","0050","0060","0070","0080","0090","0100","0110","0120","0130","0140","0150","0160","0170","0180","0190","0200","0210","0220","0230","0240","0250","0260","0270","0280"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCDigitalCameraFeaturesItemsEnum = append(productCDigitalCameraFeaturesItemsEnum, v)
	}
}

func (m *Product) validateCDigitalCameraFeaturesItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCDigitalCameraFeaturesItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCDigitalCameraFeatures(formats strfmt.Registry) error {

	if swag.IsZero(m.CDigitalCameraFeatures) { // not required
		return nil
	}

	for i := 0; i < len(m.CDigitalCameraFeatures); i++ {

		// value enum
		if err := m.validateCDigitalCameraFeaturesItemsEnum("c_digitalCameraFeatures"+"."+strconv.Itoa(i), "body", m.CDigitalCameraFeatures[i]); err != nil {
			return err
		}

	}

	return nil
}

var productCGameGenreItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Action","Educational","Kids","Racing","Role-Playing","Sports","Strategy"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCGameGenreItemsEnum = append(productCGameGenreItemsEnum, v)
	}
}

func (m *Product) validateCGameGenreItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCGameGenreItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCGameGenre(formats strfmt.Registry) error {

	if swag.IsZero(m.CGameGenre) { // not required
		return nil
	}

	for i := 0; i < len(m.CGameGenre); i++ {

		// value enum
		if err := m.validateCGameGenreItemsEnum("c_gameGenre"+"."+strconv.Itoa(i), "body", m.CGameGenre[i]); err != nil {
			return err
		}

	}

	return nil
}

var productCGpsFeaturesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040","0050","0060","0070","0080","0090","0100","0110","0120","0130","0140","0150","0160","0170","0180","0190","0200","0210","0230"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCGpsFeaturesItemsEnum = append(productCGpsFeaturesItemsEnum, v)
	}
}

func (m *Product) validateCGpsFeaturesItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCGpsFeaturesItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCGpsFeatures(formats strfmt.Registry) error {

	if swag.IsZero(m.CGpsFeatures) { // not required
		return nil
	}

	for i := 0; i < len(m.CGpsFeatures); i++ {

		// value enum
		if err := m.validateCGpsFeaturesItemsEnum("c_gpsFeatures"+"."+strconv.Itoa(i), "body", m.CGpsFeatures[i]); err != nil {
			return err
		}

	}

	return nil
}

var productCGpsTypeItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCGpsTypeItemsEnum = append(productCGpsTypeItemsEnum, v)
	}
}

func (m *Product) validateCGpsTypeItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCGpsTypeItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCGpsType(formats strfmt.Registry) error {

	if swag.IsZero(m.CGpsType) { // not required
		return nil
	}

	for i := 0; i < len(m.CGpsType); i++ {

		// value enum
		if err := m.validateCGpsTypeItemsEnum("c_gpsType"+"."+strconv.Itoa(i), "body", m.CGpsType[i]); err != nil {
			return err
		}

	}

	return nil
}

var productTypeCKidsAgePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040","0050","0060","0070"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productTypeCKidsAgePropEnum = append(productTypeCKidsAgePropEnum, v)
	}
}

const (

	// ProductCKidsAgeNr0010 captures enum value "0010"
	ProductCKidsAgeNr0010 string = "0010"

	// ProductCKidsAgeNr0020 captures enum value "0020"
	ProductCKidsAgeNr0020 string = "0020"

	// ProductCKidsAgeNr0030 captures enum value "0030"
	ProductCKidsAgeNr0030 string = "0030"

	// ProductCKidsAgeNr0040 captures enum value "0040"
	ProductCKidsAgeNr0040 string = "0040"

	// ProductCKidsAgeNr0050 captures enum value "0050"
	ProductCKidsAgeNr0050 string = "0050"

	// ProductCKidsAgeNr0060 captures enum value "0060"
	ProductCKidsAgeNr0060 string = "0060"

	// ProductCKidsAgeNr0070 captures enum value "0070"
	ProductCKidsAgeNr0070 string = "0070"
)

// prop value enum
func (m *Product) validateCKidsAgeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productTypeCKidsAgePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCKidsAge(formats strfmt.Registry) error {

	if swag.IsZero(m.CKidsAge) { // not required
		return nil
	}

	// value enum
	if err := m.validateCKidsAgeEnum("c_kidsAge", "body", m.CKidsAge); err != nil {
		return err
	}

	return nil
}

var productCMaterialTestItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["cotton","wool","polyester"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCMaterialTestItemsEnum = append(productCMaterialTestItemsEnum, v)
	}
}

func (m *Product) validateCMaterialTestItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCMaterialTestItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCMaterialTest(formats strfmt.Registry) error {

	if swag.IsZero(m.CMaterialTest) { // not required
		return nil
	}

	for i := 0; i < len(m.CMaterialTest); i++ {

		// value enum
		if err := m.validateCMaterialTestItemsEnum("c_materialTest"+"."+strconv.Itoa(i), "body", m.CMaterialTest[i]); err != nil {
			return err
		}

	}

	return nil
}

var productCMediaFormatItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040","0050","0060","0070","0080","0090","0100"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCMediaFormatItemsEnum = append(productCMediaFormatItemsEnum, v)
	}
}

func (m *Product) validateCMediaFormatItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCMediaFormatItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCMediaFormat(formats strfmt.Registry) error {

	if swag.IsZero(m.CMediaFormat) { // not required
		return nil
	}

	for i := 0; i < len(m.CMediaFormat); i++ {

		// value enum
		if err := m.validateCMediaFormatItemsEnum("c_mediaFormat"+"."+strconv.Itoa(i), "body", m.CMediaFormat[i]); err != nil {
			return err
		}

	}

	return nil
}

var productCMemoryTypeItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040","0050","0060","0070","0080","0090"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCMemoryTypeItemsEnum = append(productCMemoryTypeItemsEnum, v)
	}
}

func (m *Product) validateCMemoryTypeItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCMemoryTypeItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCMemoryType(formats strfmt.Registry) error {

	if swag.IsZero(m.CMemoryType) { // not required
		return nil
	}

	for i := 0; i < len(m.CMemoryType); i++ {

		// value enum
		if err := m.validateCMemoryTypeItemsEnum("c_memoryType"+"."+strconv.Itoa(i), "body", m.CMemoryType[i]); err != nil {
			return err
		}

	}

	return nil
}

var productTypeCOuterwearTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040","0050","0060","0070","0080"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productTypeCOuterwearTypePropEnum = append(productTypeCOuterwearTypePropEnum, v)
	}
}

const (

	// ProductCOuterwearTypeNr0010 captures enum value "0010"
	ProductCOuterwearTypeNr0010 string = "0010"

	// ProductCOuterwearTypeNr0020 captures enum value "0020"
	ProductCOuterwearTypeNr0020 string = "0020"

	// ProductCOuterwearTypeNr0030 captures enum value "0030"
	ProductCOuterwearTypeNr0030 string = "0030"

	// ProductCOuterwearTypeNr0040 captures enum value "0040"
	ProductCOuterwearTypeNr0040 string = "0040"

	// ProductCOuterwearTypeNr0050 captures enum value "0050"
	ProductCOuterwearTypeNr0050 string = "0050"

	// ProductCOuterwearTypeNr0060 captures enum value "0060"
	ProductCOuterwearTypeNr0060 string = "0060"

	// ProductCOuterwearTypeNr0070 captures enum value "0070"
	ProductCOuterwearTypeNr0070 string = "0070"

	// ProductCOuterwearTypeNr0080 captures enum value "0080"
	ProductCOuterwearTypeNr0080 string = "0080"
)

// prop value enum
func (m *Product) validateCOuterwearTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productTypeCOuterwearTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCOuterwearType(formats strfmt.Registry) error {

	if swag.IsZero(m.COuterwearType) { // not required
		return nil
	}

	// value enum
	if err := m.validateCOuterwearTypeEnum("c_outerwearType", "body", m.COuterwearType); err != nil {
		return err
	}

	return nil
}

var productCPortableAudioTypeItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCPortableAudioTypeItemsEnum = append(productCPortableAudioTypeItemsEnum, v)
	}
}

func (m *Product) validateCPortableAudioTypeItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCPortableAudioTypeItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCPortableAudioType(formats strfmt.Registry) error {

	if swag.IsZero(m.CPortableAudioType) { // not required
		return nil
	}

	for i := 0; i < len(m.CPortableAudioType); i++ {

		// value enum
		if err := m.validateCPortableAudioTypeItemsEnum("c_portableAudioType"+"."+strconv.Itoa(i), "body", m.CPortableAudioType[i]); err != nil {
			return err
		}

	}

	return nil
}

var productTypeCRefinementColorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["black","blue","green","red","orange","pink","purple","white","yellow","grey","beige","miscellaneous","brown","navy"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productTypeCRefinementColorPropEnum = append(productTypeCRefinementColorPropEnum, v)
	}
}

const (

	// ProductCRefinementColorBlack captures enum value "black"
	ProductCRefinementColorBlack string = "black"

	// ProductCRefinementColorBlue captures enum value "blue"
	ProductCRefinementColorBlue string = "blue"

	// ProductCRefinementColorGreen captures enum value "green"
	ProductCRefinementColorGreen string = "green"

	// ProductCRefinementColorRed captures enum value "red"
	ProductCRefinementColorRed string = "red"

	// ProductCRefinementColorOrange captures enum value "orange"
	ProductCRefinementColorOrange string = "orange"

	// ProductCRefinementColorPink captures enum value "pink"
	ProductCRefinementColorPink string = "pink"

	// ProductCRefinementColorPurple captures enum value "purple"
	ProductCRefinementColorPurple string = "purple"

	// ProductCRefinementColorWhite captures enum value "white"
	ProductCRefinementColorWhite string = "white"

	// ProductCRefinementColorYellow captures enum value "yellow"
	ProductCRefinementColorYellow string = "yellow"

	// ProductCRefinementColorGrey captures enum value "grey"
	ProductCRefinementColorGrey string = "grey"

	// ProductCRefinementColorBeige captures enum value "beige"
	ProductCRefinementColorBeige string = "beige"

	// ProductCRefinementColorMiscellaneous captures enum value "miscellaneous"
	ProductCRefinementColorMiscellaneous string = "miscellaneous"

	// ProductCRefinementColorBrown captures enum value "brown"
	ProductCRefinementColorBrown string = "brown"

	// ProductCRefinementColorNavy captures enum value "navy"
	ProductCRefinementColorNavy string = "navy"
)

// prop value enum
func (m *Product) validateCRefinementColorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productTypeCRefinementColorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCRefinementColor(formats strfmt.Registry) error {

	if swag.IsZero(m.CRefinementColor) { // not required
		return nil
	}

	// value enum
	if err := m.validateCRefinementColorEnum("c_refinementColor", "body", m.CRefinementColor); err != nil {
		return err
	}

	return nil
}

var productTypeCSandalTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productTypeCSandalTypePropEnum = append(productTypeCSandalTypePropEnum, v)
	}
}

const (

	// ProductCSandalTypeNr0010 captures enum value "0010"
	ProductCSandalTypeNr0010 string = "0010"

	// ProductCSandalTypeNr0020 captures enum value "0020"
	ProductCSandalTypeNr0020 string = "0020"

	// ProductCSandalTypeNr0030 captures enum value "0030"
	ProductCSandalTypeNr0030 string = "0030"
)

// prop value enum
func (m *Product) validateCSandalTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productTypeCSandalTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCSandalType(formats strfmt.Registry) error {

	if swag.IsZero(m.CSandalType) { // not required
		return nil
	}

	// value enum
	if err := m.validateCSandalTypeEnum("c_sandalType", "body", m.CSandalType); err != nil {
		return err
	}

	return nil
}

var productCSheetsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["value1","value2","value3"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCSheetsItemsEnum = append(productCSheetsItemsEnum, v)
	}
}

func (m *Product) validateCSheetsItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCSheetsItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCSheets(formats strfmt.Registry) error {

	if swag.IsZero(m.CSheets) { // not required
		return nil
	}

	for i := 0; i < len(m.CSheets); i++ {

		// value enum
		if err := m.validateCSheetsItemsEnum("c_sheets"+"."+strconv.Itoa(i), "body", m.CSheets[i]); err != nil {
			return err
		}

	}

	return nil
}

var productTypeCShoeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040","0050","0060","0070","0080","0090","0100","0110"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productTypeCShoeTypePropEnum = append(productTypeCShoeTypePropEnum, v)
	}
}

const (

	// ProductCShoeTypeNr0010 captures enum value "0010"
	ProductCShoeTypeNr0010 string = "0010"

	// ProductCShoeTypeNr0020 captures enum value "0020"
	ProductCShoeTypeNr0020 string = "0020"

	// ProductCShoeTypeNr0030 captures enum value "0030"
	ProductCShoeTypeNr0030 string = "0030"

	// ProductCShoeTypeNr0040 captures enum value "0040"
	ProductCShoeTypeNr0040 string = "0040"

	// ProductCShoeTypeNr0050 captures enum value "0050"
	ProductCShoeTypeNr0050 string = "0050"

	// ProductCShoeTypeNr0060 captures enum value "0060"
	ProductCShoeTypeNr0060 string = "0060"

	// ProductCShoeTypeNr0070 captures enum value "0070"
	ProductCShoeTypeNr0070 string = "0070"

	// ProductCShoeTypeNr0080 captures enum value "0080"
	ProductCShoeTypeNr0080 string = "0080"

	// ProductCShoeTypeNr0090 captures enum value "0090"
	ProductCShoeTypeNr0090 string = "0090"

	// ProductCShoeTypeNr0100 captures enum value "0100"
	ProductCShoeTypeNr0100 string = "0100"

	// ProductCShoeTypeNr0110 captures enum value "0110"
	ProductCShoeTypeNr0110 string = "0110"
)

// prop value enum
func (m *Product) validateCShoeTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productTypeCShoeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCShoeType(formats strfmt.Registry) error {

	if swag.IsZero(m.CShoeType) { // not required
		return nil
	}

	// value enum
	if err := m.validateCShoeTypeEnum("c_shoeType", "body", m.CShoeType); err != nil {
		return err
	}

	return nil
}

var productCSkinConcernItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["dryTight","comprehensive","liftingLossFirm"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCSkinConcernItemsEnum = append(productCSkinConcernItemsEnum, v)
	}
}

func (m *Product) validateCSkinConcernItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCSkinConcernItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCSkinConcern(formats strfmt.Registry) error {

	if swag.IsZero(m.CSkinConcern) { // not required
		return nil
	}

	for i := 0; i < len(m.CSkinConcern); i++ {

		// value enum
		if err := m.validateCSkinConcernItemsEnum("c_skinConcern"+"."+strconv.Itoa(i), "body", m.CSkinConcern[i]); err != nil {
			return err
		}

	}

	return nil
}

var productTypeCTvTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productTypeCTvTypePropEnum = append(productTypeCTvTypePropEnum, v)
	}
}

const (

	// ProductCTvTypeNr0010 captures enum value "0010"
	ProductCTvTypeNr0010 string = "0010"

	// ProductCTvTypeNr0020 captures enum value "0020"
	ProductCTvTypeNr0020 string = "0020"

	// ProductCTvTypeNr0030 captures enum value "0030"
	ProductCTvTypeNr0030 string = "0030"

	// ProductCTvTypeNr0040 captures enum value "0040"
	ProductCTvTypeNr0040 string = "0040"
)

// prop value enum
func (m *Product) validateCTvTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productTypeCTvTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCTvType(formats strfmt.Registry) error {

	if swag.IsZero(m.CTvType) { // not required
		return nil
	}

	// value enum
	if err := m.validateCTvTypeEnum("c_tvType", "body", m.CTvType); err != nil {
		return err
	}

	return nil
}

func (m *Product) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	if err := validate.MinLength("id", "body", string(*m.ID), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("id", "body", string(*m.ID), 100); err != nil {
		return err
	}

	return nil
}

func (m *Product) validateImageGroups(formats strfmt.Registry) error {

	if swag.IsZero(m.ImageGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.ImageGroups); i++ {
		if swag.IsZero(m.ImageGroups[i]) { // not required
			continue
		}

		if m.ImageGroups[i] != nil {
			if err := m.ImageGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("image_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateInventories(formats strfmt.Registry) error {

	if swag.IsZero(m.Inventories) { // not required
		return nil
	}

	for i := 0; i < len(m.Inventories); i++ {
		if swag.IsZero(m.Inventories[i]) { // not required
			continue
		}

		if m.Inventories[i] != nil {
			if err := m.Inventories[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("inventories" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateInventory(formats strfmt.Registry) error {

	if swag.IsZero(m.Inventory) { // not required
		return nil
	}

	if m.Inventory != nil {
		if err := m.Inventory.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("inventory")
			}
			return err
		}
	}

	return nil
}

func (m *Product) validateMaster(formats strfmt.Registry) error {

	if swag.IsZero(m.Master) { // not required
		return nil
	}

	if m.Master != nil {
		if err := m.Master.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("master")
			}
			return err
		}
	}

	return nil
}

func (m *Product) validateOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.Options) { // not required
		return nil
	}

	for i := 0; i < len(m.Options); i++ {
		if swag.IsZero(m.Options[i]) { // not required
			continue
		}

		if m.Options[i] != nil {
			if err := m.Options[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("options" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateProductLinks(formats strfmt.Registry) error {

	if swag.IsZero(m.ProductLinks) { // not required
		return nil
	}

	for i := 0; i < len(m.ProductLinks); i++ {
		if swag.IsZero(m.ProductLinks[i]) { // not required
			continue
		}

		if m.ProductLinks[i] != nil {
			if err := m.ProductLinks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("product_links" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateProductPromotions(formats strfmt.Registry) error {

	if swag.IsZero(m.ProductPromotions) { // not required
		return nil
	}

	for i := 0; i < len(m.ProductPromotions); i++ {
		if swag.IsZero(m.ProductPromotions[i]) { // not required
			continue
		}

		if m.ProductPromotions[i] != nil {
			if err := m.ProductPromotions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("product_promotions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateRecommendations(formats strfmt.Registry) error {

	if swag.IsZero(m.Recommendations) { // not required
		return nil
	}

	for i := 0; i < len(m.Recommendations); i++ {
		if swag.IsZero(m.Recommendations[i]) { // not required
			continue
		}

		if m.Recommendations[i] != nil {
			if err := m.Recommendations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("recommendations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateSetProducts(formats strfmt.Registry) error {

	if swag.IsZero(m.SetProducts) { // not required
		return nil
	}

	for i := 0; i < len(m.SetProducts); i++ {
		if swag.IsZero(m.SetProducts[i]) { // not required
			continue
		}

		if m.SetProducts[i] != nil {
			if err := m.SetProducts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("set_products" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	if m.Type != nil {
		if err := m.Type.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

func (m *Product) validateValidFrom(formats strfmt.Registry) error {

	if swag.IsZero(m.ValidFrom) { // not required
		return nil
	}

	if err := validate.FormatOf("valid_from", "body", "date-time", m.ValidFrom.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Product) validateValidTo(formats strfmt.Registry) error {

	if swag.IsZero(m.ValidTo) { // not required
		return nil
	}

	if err := validate.FormatOf("valid_to", "body", "date-time", m.ValidTo.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Product) validateVariants(formats strfmt.Registry) error {

	if swag.IsZero(m.Variants) { // not required
		return nil
	}

	for i := 0; i < len(m.Variants); i++ {
		if swag.IsZero(m.Variants[i]) { // not required
			continue
		}

		if m.Variants[i] != nil {
			if err := m.Variants[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("variants" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateVariationAttributes(formats strfmt.Registry) error {

	if swag.IsZero(m.VariationAttributes) { // not required
		return nil
	}

	for i := 0; i < len(m.VariationAttributes); i++ {
		if swag.IsZero(m.VariationAttributes[i]) { // not required
			continue
		}

		if m.VariationAttributes[i] != nil {
			if err := m.VariationAttributes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("variation_attributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateVariationGroups(formats strfmt.Registry) error {

	if swag.IsZero(m.VariationGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.VariationGroups); i++ {
		if swag.IsZero(m.VariationGroups[i]) { // not required
			continue
		}

		if m.VariationGroups[i] != nil {
			if err := m.VariationGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("variation_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Product) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Product) UnmarshalBinary(b []byte) error {
	var res Product
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
