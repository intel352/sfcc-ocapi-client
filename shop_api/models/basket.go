// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Basket Document representing a basket.
//
// swagger:model basket
type Basket struct {

	// The products tax after discounts applying in purchase currency.
	//
	//  Adjusted merchandize prices represent the sum of product prices before
	//  services such as shipping have been added, but after adjustment from
	//  promotions have been added.
	AdjustedMerchandizeTotalTax float64 `json:"adjusted_merchandize_total_tax,omitempty"`

	// The tax of all shipping line items of the line item container after
	//  shipping adjustments have been applied.
	AdjustedShippingTotalTax float64 `json:"adjusted_shipping_total_tax,omitempty"`

	// Is the basket created by an agent?
	AgentBasket bool `json:"agent_basket,omitempty"`

	// The unique identifier for the basket.
	BasketID string `json:"basket_id,omitempty"`

	// The billing address. This property is part of basket checkout information only.
	BillingAddress *OrderAddress `json:"billing_address,omitempty"`

	// The bonus discount line items of the line item container.
	BonusDiscountLineItems []*BonusDiscountLineItem `json:"bonus_discount_line_items"`

	// c session address book
	CSessionAddressBook string `json:"c_sessionAddressBook,omitempty"`

	// The sales channel for the order.
	// Read Only: true
	// Enum: [storefront callcenter marketplace dss store pinterest twitter facebookads subscriptions onlinereservation customerservicecenter instagramcommerce]
	ChannelType string `json:"channel_type,omitempty"`

	// The sorted array of coupon items. This array can be empty.
	CouponItems []*CouponItem `json:"coupon_items"`

	// Returns the value of attribute 'creationDate'.
	// Read Only: true
	// Format: date-time
	CreationDate strfmt.DateTime `json:"creation_date,omitempty"`

	// The ISO 4217 mnemonic code of the currency.
	Currency string `json:"currency,omitempty"`

	// The customer information for logged in customers. This property is part of basket checkout information only.
	CustomerInfo *CustomerInfo `json:"customer_info,omitempty"`

	// The sorted array of gift certificate line items. This array can be empty.
	GiftCertificateItems []*GiftCertificateItem `json:"gift_certificate_items"`

	// inventory reservation expiry
	// Format: date-time
	InventoryReservationExpiry strfmt.DateTime `json:"inventory_reservation_expiry,omitempty"`

	// Returns the value of attribute 'lastModified'.
	// Read Only: true
	// Format: date-time
	LastModified strfmt.DateTime `json:"last_modified,omitempty"`

	// The products total tax in purchase currency.
	//
	//  Merchandize total prices represent the sum of product prices before
	//  services such as shipping or adjustment from promotions have
	//  been added.
	MerchandizeTotalTax float64 `json:"merchandize_total_tax,omitempty"`

	// The notes for the line item container.
	Notes *SimpleLink `json:"notes,omitempty"`

	// The array of order level price adjustments. This array can be empty.
	OrderPriceAdjustments []*PriceAdjustment `json:"order_price_adjustments"`

	// The total price of the order, including products, shipping and tax. This property is part of basket checkout
	//  information only.
	OrderTotal float64 `json:"order_total,omitempty"`

	// The payment instruments list for the order.
	PaymentInstruments []*OrderPaymentInstrument `json:"payment_instruments"`

	// The sorted array of product items (up to a maximum of 50 items). This array can be empty.
	ProductItems []*ProductItem `json:"product_items"`

	// The total price of all product items after all product discounts.
	//  Depending on taxation policy the returned price is net or gross.
	ProductSubTotal float64 `json:"product_sub_total,omitempty"`

	// The total price of all product items after all product and order discounts.
	//  Depending on taxation policy the returned price is net or gross.
	ProductTotal float64 `json:"product_total,omitempty"`

	// The array of shipments. This property is part of basket checkout information only.
	Shipments []*Shipment `json:"shipments"`

	// The sorted array of shipping items. This array can be empty.
	ShippingItems []*ShippingItem `json:"shipping_items"`

	// The total shipping price of the order after all shipping discounts. Excludes tax if taxation policy is net. Includes
	//  tax if taxation policy is gross. This property is part of basket checkout information only.
	ShippingTotal float64 `json:"shipping_total,omitempty"`

	// The tax of all shipping line items of the line item container before
	//  shipping adjustments have been applied.
	ShippingTotalTax float64 `json:"shipping_total_tax,omitempty"`

	// Gets the source code assigned to this basket.
	SourceCode string `json:"source_code,omitempty"`

	// The total tax amount of the order. This property is part of basket checkout information only.
	TaxTotal float64 `json:"tax_total,omitempty"`

	// The taxation the line item container is based on.
	// Enum: [gross net]
	Taxation string `json:"taxation,omitempty"`
}

// Validate validates this basket
func (m *Basket) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBillingAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBonusDiscountLineItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChannelType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCouponItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomerInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGiftCertificateItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInventoryReservationExpiry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastModified(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderPriceAdjustments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymentInstruments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShipments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShippingItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Basket) validateBillingAddress(formats strfmt.Registry) error {

	if swag.IsZero(m.BillingAddress) { // not required
		return nil
	}

	if m.BillingAddress != nil {
		if err := m.BillingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billing_address")
			}
			return err
		}
	}

	return nil
}

func (m *Basket) validateBonusDiscountLineItems(formats strfmt.Registry) error {

	if swag.IsZero(m.BonusDiscountLineItems) { // not required
		return nil
	}

	for i := 0; i < len(m.BonusDiscountLineItems); i++ {
		if swag.IsZero(m.BonusDiscountLineItems[i]) { // not required
			continue
		}

		if m.BonusDiscountLineItems[i] != nil {
			if err := m.BonusDiscountLineItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("bonus_discount_line_items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var basketTypeChannelTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["storefront","callcenter","marketplace","dss","store","pinterest","twitter","facebookads","subscriptions","onlinereservation","customerservicecenter","instagramcommerce"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		basketTypeChannelTypePropEnum = append(basketTypeChannelTypePropEnum, v)
	}
}

const (

	// BasketChannelTypeStorefront captures enum value "storefront"
	BasketChannelTypeStorefront string = "storefront"

	// BasketChannelTypeCallcenter captures enum value "callcenter"
	BasketChannelTypeCallcenter string = "callcenter"

	// BasketChannelTypeMarketplace captures enum value "marketplace"
	BasketChannelTypeMarketplace string = "marketplace"

	// BasketChannelTypeDss captures enum value "dss"
	BasketChannelTypeDss string = "dss"

	// BasketChannelTypeStore captures enum value "store"
	BasketChannelTypeStore string = "store"

	// BasketChannelTypePinterest captures enum value "pinterest"
	BasketChannelTypePinterest string = "pinterest"

	// BasketChannelTypeTwitter captures enum value "twitter"
	BasketChannelTypeTwitter string = "twitter"

	// BasketChannelTypeFacebookads captures enum value "facebookads"
	BasketChannelTypeFacebookads string = "facebookads"

	// BasketChannelTypeSubscriptions captures enum value "subscriptions"
	BasketChannelTypeSubscriptions string = "subscriptions"

	// BasketChannelTypeOnlinereservation captures enum value "onlinereservation"
	BasketChannelTypeOnlinereservation string = "onlinereservation"

	// BasketChannelTypeCustomerservicecenter captures enum value "customerservicecenter"
	BasketChannelTypeCustomerservicecenter string = "customerservicecenter"

	// BasketChannelTypeInstagramcommerce captures enum value "instagramcommerce"
	BasketChannelTypeInstagramcommerce string = "instagramcommerce"
)

// prop value enum
func (m *Basket) validateChannelTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, basketTypeChannelTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Basket) validateChannelType(formats strfmt.Registry) error {

	if swag.IsZero(m.ChannelType) { // not required
		return nil
	}

	// value enum
	if err := m.validateChannelTypeEnum("channel_type", "body", m.ChannelType); err != nil {
		return err
	}

	return nil
}

func (m *Basket) validateCouponItems(formats strfmt.Registry) error {

	if swag.IsZero(m.CouponItems) { // not required
		return nil
	}

	for i := 0; i < len(m.CouponItems); i++ {
		if swag.IsZero(m.CouponItems[i]) { // not required
			continue
		}

		if m.CouponItems[i] != nil {
			if err := m.CouponItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("coupon_items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Basket) validateCreationDate(formats strfmt.Registry) error {

	if swag.IsZero(m.CreationDate) { // not required
		return nil
	}

	if err := validate.FormatOf("creation_date", "body", "date-time", m.CreationDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Basket) validateCustomerInfo(formats strfmt.Registry) error {

	if swag.IsZero(m.CustomerInfo) { // not required
		return nil
	}

	if m.CustomerInfo != nil {
		if err := m.CustomerInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customer_info")
			}
			return err
		}
	}

	return nil
}

func (m *Basket) validateGiftCertificateItems(formats strfmt.Registry) error {

	if swag.IsZero(m.GiftCertificateItems) { // not required
		return nil
	}

	for i := 0; i < len(m.GiftCertificateItems); i++ {
		if swag.IsZero(m.GiftCertificateItems[i]) { // not required
			continue
		}

		if m.GiftCertificateItems[i] != nil {
			if err := m.GiftCertificateItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("gift_certificate_items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Basket) validateInventoryReservationExpiry(formats strfmt.Registry) error {

	if swag.IsZero(m.InventoryReservationExpiry) { // not required
		return nil
	}

	if err := validate.FormatOf("inventory_reservation_expiry", "body", "date-time", m.InventoryReservationExpiry.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Basket) validateLastModified(formats strfmt.Registry) error {

	if swag.IsZero(m.LastModified) { // not required
		return nil
	}

	if err := validate.FormatOf("last_modified", "body", "date-time", m.LastModified.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Basket) validateNotes(formats strfmt.Registry) error {

	if swag.IsZero(m.Notes) { // not required
		return nil
	}

	if m.Notes != nil {
		if err := m.Notes.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("notes")
			}
			return err
		}
	}

	return nil
}

func (m *Basket) validateOrderPriceAdjustments(formats strfmt.Registry) error {

	if swag.IsZero(m.OrderPriceAdjustments) { // not required
		return nil
	}

	for i := 0; i < len(m.OrderPriceAdjustments); i++ {
		if swag.IsZero(m.OrderPriceAdjustments[i]) { // not required
			continue
		}

		if m.OrderPriceAdjustments[i] != nil {
			if err := m.OrderPriceAdjustments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("order_price_adjustments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Basket) validatePaymentInstruments(formats strfmt.Registry) error {

	if swag.IsZero(m.PaymentInstruments) { // not required
		return nil
	}

	for i := 0; i < len(m.PaymentInstruments); i++ {
		if swag.IsZero(m.PaymentInstruments[i]) { // not required
			continue
		}

		if m.PaymentInstruments[i] != nil {
			if err := m.PaymentInstruments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("payment_instruments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Basket) validateProductItems(formats strfmt.Registry) error {

	if swag.IsZero(m.ProductItems) { // not required
		return nil
	}

	for i := 0; i < len(m.ProductItems); i++ {
		if swag.IsZero(m.ProductItems[i]) { // not required
			continue
		}

		if m.ProductItems[i] != nil {
			if err := m.ProductItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("product_items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Basket) validateShipments(formats strfmt.Registry) error {

	if swag.IsZero(m.Shipments) { // not required
		return nil
	}

	for i := 0; i < len(m.Shipments); i++ {
		if swag.IsZero(m.Shipments[i]) { // not required
			continue
		}

		if m.Shipments[i] != nil {
			if err := m.Shipments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("shipments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Basket) validateShippingItems(formats strfmt.Registry) error {

	if swag.IsZero(m.ShippingItems) { // not required
		return nil
	}

	for i := 0; i < len(m.ShippingItems); i++ {
		if swag.IsZero(m.ShippingItems[i]) { // not required
			continue
		}

		if m.ShippingItems[i] != nil {
			if err := m.ShippingItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("shipping_items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var basketTypeTaxationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["gross","net"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		basketTypeTaxationPropEnum = append(basketTypeTaxationPropEnum, v)
	}
}

const (

	// BasketTaxationGross captures enum value "gross"
	BasketTaxationGross string = "gross"

	// BasketTaxationNet captures enum value "net"
	BasketTaxationNet string = "net"
)

// prop value enum
func (m *Basket) validateTaxationEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, basketTypeTaxationPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Basket) validateTaxation(formats strfmt.Registry) error {

	if swag.IsZero(m.Taxation) { // not required
		return nil
	}

	// value enum
	if err := m.validateTaxationEnum("taxation", "body", m.Taxation); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Basket) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Basket) UnmarshalBinary(b []byte) error {
	var res Basket
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
