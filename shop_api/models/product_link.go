// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ProductLink Document representing a link between two products. It contains the id of the source and target products, the type of
//  product link, and URLs to retrieve product data.
// swagger:model product_link
type ProductLink struct {

	// The semantic id of the product from which this product link is coming.
	SourceProductID string `json:"source_product_id,omitempty"`

	// The URL addressing the product from which this product link is coming.
	SourceProductLink string `json:"source_product_link,omitempty"`

	// The semantic id of the product to which this product link is pointing.
	TargetProductID string `json:"target_product_id,omitempty"`

	// The URL addressing the product to which this product link is pointing.
	TargetProductLink string `json:"target_product_link,omitempty"`

	// The type of this product link.
	// Enum: [cross_sell replacement up_sell accessory newer_version alt_orderunit spare_part other]
	Type string `json:"type,omitempty"`
}

// Validate validates this product link
func (m *ProductLink) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var productLinkTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["cross_sell","replacement","up_sell","accessory","newer_version","alt_orderunit","spare_part","other"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productLinkTypeTypePropEnum = append(productLinkTypeTypePropEnum, v)
	}
}

const (

	// ProductLinkTypeCrossSell captures enum value "cross_sell"
	ProductLinkTypeCrossSell string = "cross_sell"

	// ProductLinkTypeReplacement captures enum value "replacement"
	ProductLinkTypeReplacement string = "replacement"

	// ProductLinkTypeUpSell captures enum value "up_sell"
	ProductLinkTypeUpSell string = "up_sell"

	// ProductLinkTypeAccessory captures enum value "accessory"
	ProductLinkTypeAccessory string = "accessory"

	// ProductLinkTypeNewerVersion captures enum value "newer_version"
	ProductLinkTypeNewerVersion string = "newer_version"

	// ProductLinkTypeAltOrderunit captures enum value "alt_orderunit"
	ProductLinkTypeAltOrderunit string = "alt_orderunit"

	// ProductLinkTypeSparePart captures enum value "spare_part"
	ProductLinkTypeSparePart string = "spare_part"

	// ProductLinkTypeOther captures enum value "other"
	ProductLinkTypeOther string = "other"
)

// prop value enum
func (m *ProductLink) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productLinkTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductLink) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ProductLink) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProductLink) UnmarshalBinary(b []byte) error {
	var res ProductLink
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
