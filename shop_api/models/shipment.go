// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Shipment Document representing a shipment.
// swagger:model shipment
type Shipment struct {

	// The products tax after discounts applying in purchase currency. Adjusted merchandize prices represent the sum of
	//  product prices before services such as shipping have been added, but after adjustment from promotions have been
	//  added.
	//
	//  Note that order level adjustments are considered if Discount Taxation preference is set to
	//  "Tax Products and Shipping Only Based on Adjusted Price".
	AdjustedMerchandizeTotalTax float64 `json:"adjusted_merchandize_total_tax,omitempty"`

	// The tax of all shipping line items of the line item container after shipping adjustments have been applied.
	AdjustedShippingTotalTax float64 `json:"adjusted_shipping_total_tax,omitempty"`

	// Used to map the shipment to a  brick and mortar store.
	CFromStoreID string `json:"c_fromStoreId,omitempty"`

	// c shipment type
	CShipmentType string `json:"c_shipmentType,omitempty"`

	// This is text used by the end user when sending a message to the brick and mortar store about the shipment.  This is reflected in the order export.
	CStorePickupMessage string `json:"c_storePickupMessage,omitempty"`

	// A flag indicating whether the shipment is a gift.
	Gift bool `json:"gift,omitempty"`

	// The gift message.
	GiftMessage string `json:"gift_message,omitempty"`

	// The products total tax in purchase currency. Merchandize total prices represent the sum of product prices before
	//  services such as shipping or adjustment from promotions have been added.
	MerchandizeTotalTax float64 `json:"merchandize_total_tax,omitempty"`

	// The total price of all product items after all product discounts. Depending on taxation policy the returned price
	//  is net or gross.
	ProductSubTotal float64 `json:"product_sub_total,omitempty"`

	// The total price of all product items after all product and order discounts. Depending on taxation policy the
	//  returned price is net or gross.
	ProductTotal float64 `json:"product_total,omitempty"`

	// The order specific id to identify the shipment.
	ShipmentID string `json:"shipment_id,omitempty"`

	// Returns the shipment number for this shipment.
	//
	//  This number is automatically generated.
	ShipmentNo string `json:"shipment_no,omitempty"`

	// The total price of the shipment, including products, shipping and tax.
	//
	//  Note that order level adjustments are not considered.
	ShipmentTotal float64 `json:"shipment_total,omitempty"`

	// The shipping address.
	ShippingAddress *OrderAddress `json:"shipping_address,omitempty"`

	// The shipping method.
	ShippingMethod *ShippingMethod `json:"shipping_method,omitempty"`

	// The shipping status of the shipment.
	// Required: true
	// Enum: [not_shipped shipped]
	ShippingStatus *string `json:"shipping_status"`

	// The total shipping price of the shipment after all shipping discounts. Excludes tax if taxation policy is net.
	//  Includes tax if taxation policy is gross.
	ShippingTotal float64 `json:"shipping_total,omitempty"`

	// The tax of all shipping line items of the line item container before shipping adjustments have been applied.
	ShippingTotalTax float64 `json:"shipping_total_tax,omitempty"`

	// The total tax amount of the shipment.
	//
	//  Note that order level adjustments are considered if Discount Taxation preference is set to
	//  "Tax Products and Shipping Only Based on Adjusted Price".
	TaxTotal float64 `json:"tax_total,omitempty"`

	// The tracking number of the shipment.
	TrackingNumber string `json:"tracking_number,omitempty"`
}

// Validate validates this shipment
func (m *Shipment) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateShippingAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShippingMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShippingStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Shipment) validateShippingAddress(formats strfmt.Registry) error {

	if swag.IsZero(m.ShippingAddress) { // not required
		return nil
	}

	if m.ShippingAddress != nil {
		if err := m.ShippingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shipping_address")
			}
			return err
		}
	}

	return nil
}

func (m *Shipment) validateShippingMethod(formats strfmt.Registry) error {

	if swag.IsZero(m.ShippingMethod) { // not required
		return nil
	}

	if m.ShippingMethod != nil {
		if err := m.ShippingMethod.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shipping_method")
			}
			return err
		}
	}

	return nil
}

var shipmentTypeShippingStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["not_shipped","shipped"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shipmentTypeShippingStatusPropEnum = append(shipmentTypeShippingStatusPropEnum, v)
	}
}

const (

	// ShipmentShippingStatusNotShipped captures enum value "not_shipped"
	ShipmentShippingStatusNotShipped string = "not_shipped"

	// ShipmentShippingStatusShipped captures enum value "shipped"
	ShipmentShippingStatusShipped string = "shipped"
)

// prop value enum
func (m *Shipment) validateShippingStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, shipmentTypeShippingStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Shipment) validateShippingStatus(formats strfmt.Registry) error {

	if err := validate.Required("shipping_status", "body", m.ShippingStatus); err != nil {
		return err
	}

	// value enum
	if err := m.validateShippingStatusEnum("shipping_status", "body", *m.ShippingStatus); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Shipment) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Shipment) UnmarshalBinary(b []byte) error {
	var res Shipment
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
