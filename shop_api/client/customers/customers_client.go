// Code generated by go-swagger; DO NOT EDIT.

package customers

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new customers API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for customers API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
DeleteCustomersAuth Invalidates the JWT provided in the header.
*/
func (a *Client) DeleteCustomersAuth(params *DeleteCustomersAuthParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteCustomersAuthNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteCustomersAuthParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteCustomersAuth",
		Method:             "DELETE",
		PathPattern:        "/customers/auth",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteCustomersAuthReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteCustomersAuthNoContent), nil

}

/*
DeleteCustomersByIDAddressesByID Deletes a customer's address by address name.
*/
func (a *Client) DeleteCustomersByIDAddressesByID(params *DeleteCustomersByIDAddressesByIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteCustomersByIDAddressesByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteCustomersByIDAddressesByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteCustomersByIDAddressesByID",
		Method:             "DELETE",
		PathPattern:        "/customers/{customer_id}/addresses/{address_name}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteCustomersByIDAddressesByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteCustomersByIDAddressesByIDNoContent), nil

}

/*
DeleteCustomersByIDPaymentInstrumentsByID Deletes a customer's payment instrument.
*/
func (a *Client) DeleteCustomersByIDPaymentInstrumentsByID(params *DeleteCustomersByIDPaymentInstrumentsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteCustomersByIDPaymentInstrumentsByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteCustomersByIDPaymentInstrumentsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteCustomersByIDPaymentInstrumentsByID",
		Method:             "DELETE",
		PathPattern:        "/customers/{customer_id}/payment_instruments/{payment_instrument_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteCustomersByIDPaymentInstrumentsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteCustomersByIDPaymentInstrumentsByIDNoContent), nil

}

/*
DeleteCustomersByIDProductListsByID Deletes a customer product list.
*/
func (a *Client) DeleteCustomersByIDProductListsByID(params *DeleteCustomersByIDProductListsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteCustomersByIDProductListsByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteCustomersByIDProductListsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteCustomersByIDProductListsByID",
		Method:             "DELETE",
		PathPattern:        "/customers/{customer_id}/product_lists/{list_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteCustomersByIDProductListsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteCustomersByIDProductListsByIDNoContent), nil

}

/*
DeleteCustomersByIDProductListsByIDItemsByID Removes an item from a customer product list.
*/
func (a *Client) DeleteCustomersByIDProductListsByIDItemsByID(params *DeleteCustomersByIDProductListsByIDItemsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteCustomersByIDProductListsByIDItemsByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteCustomersByIDProductListsByIDItemsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteCustomersByIDProductListsByIDItemsByID",
		Method:             "DELETE",
		PathPattern:        "/customers/{customer_id}/product_lists/{list_id}/items/{item_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteCustomersByIDProductListsByIDItemsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteCustomersByIDProductListsByIDItemsByIDNoContent), nil

}

/*
GetCustomersByID Gets a customer.
*/
func (a *Client) GetCustomersByID(params *GetCustomersByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCustomersByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getCustomersByID",
		Method:             "GET",
		PathPattern:        "/customers/{customer_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCustomersByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetCustomersByIDAddresses Returns a sorted pageable list of all customer addresses in the address book. The default page size is 10
 customer addresses. The addresses are sorted so that the preferred address is always sorted first. The remaining
 addresses are sorted alphabetically by ID.

 When the customer cannot be found CustomerNotFoundException
 is thrown in a case of an agent but an empty result list is returned in a case of JWT.
*/
func (a *Client) GetCustomersByIDAddresses(params *GetCustomersByIDAddressesParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCustomersByIDAddressesParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getCustomersByIDAddresses",
		Method:             "GET",
		PathPattern:        "/customers/{customer_id}/addresses",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCustomersByIDAddressesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetCustomersByIDAddressesByID Retrieves a customer's address by address name.
*/
func (a *Client) GetCustomersByIDAddressesByID(params *GetCustomersByIDAddressesByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCustomersByIDAddressesByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getCustomersByIDAddressesByID",
		Method:             "GET",
		PathPattern:        "/customers/{customer_id}/addresses/{address_name}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCustomersByIDAddressesByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetCustomersByIDBaskets Gets the baskets of a customer.
*/
func (a *Client) GetCustomersByIDBaskets(params *GetCustomersByIDBasketsParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCustomersByIDBasketsParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getCustomersByIDBaskets",
		Method:             "GET",
		PathPattern:        "/customers/{customer_id}/baskets",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCustomersByIDBasketsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetCustomersByIDOrders Returns a pageable list of all customer's orders. The default page size is 10.
*/
func (a *Client) GetCustomersByIDOrders(params *GetCustomersByIDOrdersParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCustomersByIDOrdersParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getCustomersByIDOrders",
		Method:             "GET",
		PathPattern:        "/customers/{customer_id}/orders",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCustomersByIDOrdersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetCustomersByIDPaymentInstruments Gets customer payment instruments for an customer.  Can be limited to a specific payment
 method by providing query parameter payment_method_id.

 When the customer cannot be found CustomerNotFoundException
 is thrown in a case of an agent but an empty result list is returned in a case of JWT.
*/
func (a *Client) GetCustomersByIDPaymentInstruments(params *GetCustomersByIDPaymentInstrumentsParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCustomersByIDPaymentInstrumentsParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getCustomersByIDPaymentInstruments",
		Method:             "GET",
		PathPattern:        "/customers/{customer_id}/payment_instruments",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCustomersByIDPaymentInstrumentsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetCustomersByIDPaymentInstrumentsByID Retrieves a customer's payment instrument by its id.
*/
func (a *Client) GetCustomersByIDPaymentInstrumentsByID(params *GetCustomersByIDPaymentInstrumentsByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCustomersByIDPaymentInstrumentsByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getCustomersByIDPaymentInstrumentsByID",
		Method:             "GET",
		PathPattern:        "/customers/{customer_id}/payment_instruments/{payment_instrument_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCustomersByIDPaymentInstrumentsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetCustomersByIDProductLists Returns all customer product lists.
*/
func (a *Client) GetCustomersByIDProductLists(params *GetCustomersByIDProductListsParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCustomersByIDProductListsParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getCustomersByIDProductLists",
		Method:             "GET",
		PathPattern:        "/customers/{customer_id}/product_lists",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCustomersByIDProductListsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetCustomersByIDProductListsByID Returns a customer product list of the given customer.
*/
func (a *Client) GetCustomersByIDProductListsByID(params *GetCustomersByIDProductListsByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCustomersByIDProductListsByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getCustomersByIDProductListsByID",
		Method:             "GET",
		PathPattern:        "/customers/{customer_id}/product_lists/{list_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCustomersByIDProductListsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetCustomersByIDProductListsByIDItems Returns a pageable list of all items of a customer's product list. The default page size is 10.
*/
func (a *Client) GetCustomersByIDProductListsByIDItems(params *GetCustomersByIDProductListsByIDItemsParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCustomersByIDProductListsByIDItemsParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getCustomersByIDProductListsByIDItems",
		Method:             "GET",
		PathPattern:        "/customers/{customer_id}/product_lists/{list_id}/items",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCustomersByIDProductListsByIDItemsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetCustomersByIDProductListsByIDItemsByID Returns an item of a customer product list.
*/
func (a *Client) GetCustomersByIDProductListsByIDItemsByID(params *GetCustomersByIDProductListsByIDItemsByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCustomersByIDProductListsByIDItemsByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getCustomersByIDProductListsByIDItemsByID",
		Method:             "GET",
		PathPattern:        "/customers/{customer_id}/product_lists/{list_id}/items/{item_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCustomersByIDProductListsByIDItemsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetCustomersByIDProductListsByIDItemsByIDPurchases Returns a list of all purchases of an item from a customer's product list.
*/
func (a *Client) GetCustomersByIDProductListsByIDItemsByIDPurchases(params *GetCustomersByIDProductListsByIDItemsByIDPurchasesParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCustomersByIDProductListsByIDItemsByIDPurchasesParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getCustomersByIDProductListsByIDItemsByIDPurchases",
		Method:             "GET",
		PathPattern:        "/customers/{customer_id}/product_lists/{list_id}/items/{item_id}/purchases",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCustomersByIDProductListsByIDItemsByIDPurchasesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetCustomersByIDProductListsByIDItemsByIDPurchasesByID Returns a purchase of an item from a customer's product list.
*/
func (a *Client) GetCustomersByIDProductListsByIDItemsByIDPurchasesByID(params *GetCustomersByIDProductListsByIDItemsByIDPurchasesByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCustomersByIDProductListsByIDItemsByIDPurchasesByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getCustomersByIDProductListsByIDItemsByIDPurchasesByID",
		Method:             "GET",
		PathPattern:        "/customers/{customer_id}/product_lists/{list_id}/items/{item_id}/purchases/{purchase_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCustomersByIDProductListsByIDItemsByIDPurchasesByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PatchCustomersByID Updates a customer.
*/
func (a *Client) PatchCustomersByID(params *PatchCustomersByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchCustomersByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchCustomersByID",
		Method:             "PATCH",
		PathPattern:        "/customers/{customer_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PatchCustomersByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PatchCustomersByIDAddressesByID Updates a customer's address by address name.
*/
func (a *Client) PatchCustomersByIDAddressesByID(params *PatchCustomersByIDAddressesByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchCustomersByIDAddressesByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchCustomersByIDAddressesByID",
		Method:             "PATCH",
		PathPattern:        "/customers/{customer_id}/addresses/{address_name}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PatchCustomersByIDAddressesByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PatchCustomersByIDProductListsByID Changes a product list. Changeable properties are the name, description and if the list is public.
*/
func (a *Client) PatchCustomersByIDProductListsByID(params *PatchCustomersByIDProductListsByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchCustomersByIDProductListsByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchCustomersByIDProductListsByID",
		Method:             "PATCH",
		PathPattern:        "/customers/{customer_id}/product_lists/{list_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PatchCustomersByIDProductListsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PatchCustomersByIDProductListsByIDItemsByID Updates an item of a customer's product list.
 Considered values from the request body are:

 priority: This is the priority of the customer's product list item.
 public: This is the flag whether the customer's product list item is public.
 quantity: used for product item type only. This is the quantity of
 the customer's product list item.
 custom properties in the form c_<CUSTOM_NAME>: the custom property
 must correspond to a custom attribute (<CUSTOM_NAME>) defined for ProductListItem.
 The value of this property must be valid for the type of custom attribute defined for ProductListItem.

*/
func (a *Client) PatchCustomersByIDProductListsByIDItemsByID(params *PatchCustomersByIDProductListsByIDItemsByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchCustomersByIDProductListsByIDItemsByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchCustomersByIDProductListsByIDItemsByID",
		Method:             "PATCH",
		PathPattern:        "/customers/{customer_id}/product_lists/{list_id}/items/{item_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PatchCustomersByIDProductListsByIDItemsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PatchCustomersByIDProductListsByIDItemsByIDPurchasesByID Updates a purchase of an item from a customer's product list.
 Considered values from the request body are:

 custom properties in the form c_<CUSTOM_NAME>: the custom property
 must correspond to a custom attribute (<CUSTOM_NAME>) defined for ProductListItemPurchase.
 The value of this property must be valid for the type of custom attribute defined for ProductListItemPurchase.

*/
func (a *Client) PatchCustomersByIDProductListsByIDItemsByIDPurchasesByID(params *PatchCustomersByIDProductListsByIDItemsByIDPurchasesByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchCustomersByIDProductListsByIDItemsByIDPurchasesByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchCustomersByIDProductListsByIDItemsByIDPurchasesByID",
		Method:             "PATCH",
		PathPattern:        "/customers/{customer_id}/product_lists/{list_id}/items/{item_id}/purchases/{purchase_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PatchCustomersByIDProductListsByIDItemsByIDPurchasesByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PostCustomers Registers a customer.
 The mandatory data are the credentials and profile last name and email.
 When using OAuth the password in the request must not be set, otherwise an InvalidPasswordException will be thrown.
 When using JWT the password is required.
*/
func (a *Client) PostCustomers(params *PostCustomersParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostCustomersParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postCustomers",
		Method:             "POST",
		PathPattern:        "/customers",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PostCustomersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PostCustomersAuth Obtains a new JWT (JSON Web Token) for a guest or registered
 customer. Tokens are returned as a HTTP Authorization:Bearer response
 header entry. These kinds of request are supported, as specified by the
 type:

 Type guest - creates a new guest (non-authenticated) customer
 and returns a token for the customer.
 Type credentials - authenticates credentials passed in the
 HTTP Authorization:Basic request header, returning a token for a
 successfully authenticated customer otherwise results in an
 AuthenticationFailedException.
 Type session - authenticates the customer (anonymous or registered)
 on base of dwsid and dwsecuretoken cookies. It returns a token for a
 successfully authenticated customer, otherwise results in an
 AuthenticationFailedException.
 Type refresh - examines the token passed in the HTTP
 Authorization:Bearer request header and when valid returns a new token
 with an updated expiry time.


 For a request of type credentials:

 Updates profile attributes for the customer (for example,
 "last-visited").
 Handles the maximum number of failed login attempts.

 For a request of type session:

 Does not touch profile attributes for the registered customer (for example,
 "last-visited"), since this is not a real login.
 Returns different tokens for multiple requests with the same session id. Means, there should be
 only one call per session.


 About JWT The token contains 3 sections:

 the header section (specifies token type and algorithm used)
 the payload section (contains customer information, client id,
 issue and expiration time)
 finally the signature section records the token signature.

 A token is created and returned to the client whenever a registered
 customer logs in (type "credentials") or a guest customer requests it (type
 "guest"). The token is returned in the response header as
 Authorization: Bearer --token--

 The client has to include the token in the request header as
 Authorization: Bearer --token--
 in any follow up request. The server declines any follow up requests
 without a token or which cannot be verified based on the token signature
 or expiration time. A token nearing its expiration time should be
 exchanged for a new one (type "refresh").

 See "API Usage > JWT" for more details on using JWT as an authentication
 mechanism.
*/
func (a *Client) PostCustomersAuth(params *PostCustomersAuthParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostCustomersAuthParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postCustomersAuth",
		Method:             "POST",
		PathPattern:        "/customers/auth",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PostCustomersAuthReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PostCustomersByIDAddresses Creates a new address with the given name for the given customer.
*/
func (a *Client) PostCustomersByIDAddresses(params *PostCustomersByIDAddressesParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostCustomersByIDAddressesParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postCustomersByIDAddresses",
		Method:             "POST",
		PathPattern:        "/customers/{customer_id}/addresses",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PostCustomersByIDAddressesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PostCustomersByIDAuth
 Obtains a new agent on behalf token for a registered customer. Token is returned as a HTTP Authorization:Bearer
 response header entry.


 A token is created and returned to the client whenever an agent with Create_Order_On_Behalf_Of
 permission calls the resource for a registered customer.


 The token is returned in the response header as Authorization: Bearer --token--.


 The client has to include the token in the request header as Authorization: Bearer --token--

 in any follow up request, the agent will do on behalf of the customer.

 About the order on behalf token


 The token contains 3 sections:


 the header section (specifies token type and algorithm used)
 the payload section (contains customer information, client id, issue and expiration time)
 finally the signature section records the token signature.


 A token nearing its expiration time should be exchanged for a new one by calling this resource once more.

*/
func (a *Client) PostCustomersByIDAuth(params *PostCustomersByIDAuthParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostCustomersByIDAuthParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postCustomersByIDAuth",
		Method:             "POST",
		PathPattern:        "/customers/{customer_id}/auth",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PostCustomersByIDAuthReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PostCustomersByIDPasswordReset Starts a password reset process. A password reset token is generated and passed together with the customer
 resolved by the id provided as path parameter to a afterPOST hook. The hook
 dw.ocapi.shop.customer.password_reset.afterPOST can utilize the provided reset token, for example to send a reset email.
*/
func (a *Client) PostCustomersByIDPasswordReset(params *PostCustomersByIDPasswordResetParams, authInfo runtime.ClientAuthInfoWriter) (*PostCustomersByIDPasswordResetNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostCustomersByIDPasswordResetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postCustomersByIDPasswordReset",
		Method:             "POST",
		PathPattern:        "/customers/{customer_id}/password_reset",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PostCustomersByIDPasswordResetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostCustomersByIDPasswordResetNoContent), nil

}

/*
PostCustomersByIDPaymentInstruments Adds a payment instrument to a customer information.
*/
func (a *Client) PostCustomersByIDPaymentInstruments(params *PostCustomersByIDPaymentInstrumentsParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostCustomersByIDPaymentInstrumentsParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postCustomersByIDPaymentInstruments",
		Method:             "POST",
		PathPattern:        "/customers/{customer_id}/payment_instruments",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PostCustomersByIDPaymentInstrumentsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PostCustomersByIDProductLists Creates a customer product list.
*/
func (a *Client) PostCustomersByIDProductLists(params *PostCustomersByIDProductListsParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostCustomersByIDProductListsParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postCustomersByIDProductLists",
		Method:             "POST",
		PathPattern:        "/customers/{customer_id}/product_lists",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PostCustomersByIDProductListsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PostCustomersByIDProductListsByIDItems Adds an item to the customer's product list. Considered values from the request body are:

 type: a valid type, mandatory. This is the type of the item to be added to the customer's product
 list.
 priority: This is the priority of the item to be added to the customer's product list.
 public: This is the flag whether the item to be added to the customer's product list is public.
 product_id: a valid product id, used for product item type only. This is the id (sku)
 of the product related to the item to be added to the customer's product list. It is mandatory for
 product item type and it must be a valid product id, otherwise
 ProductListProductIdMissingException or ProductListProductNotFoundException
 will be thrown.
 quantity: used for product item type only. This is the quantity of the item to be
 added to the customer's product list.
 custom properties in the form c_<CUSTOM_NAME>: the custom property must correspond to a custom
 attribute (<CUSTOM_NAME>) defined for ProductListItem. The value of this property must be valid for the
 type of custom attribute defined for ProductListItem.

*/
func (a *Client) PostCustomersByIDProductListsByIDItems(params *PostCustomersByIDProductListsByIDItemsParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostCustomersByIDProductListsByIDItemsParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postCustomersByIDProductListsByIDItems",
		Method:             "POST",
		PathPattern:        "/customers/{customer_id}/product_lists/{list_id}/items",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PostCustomersByIDProductListsByIDItemsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PostCustomersByIDProductListsByIDItemsByIDPurchases Adds a purchase to an item in the customer's product list. Considered values from the request body are:

 purchaser_name: name of the purchaser, mandatory. This is the full name of the purchaser of this product
 list item.
 quantity: amount purchased, mandatory. This is the quantity of the items purchased from
 the product list.
 custom properties in the form c_<CUSTOM_NAME>: the custom property must correspond to a custom
 attribute (<CUSTOM_NAME>) defined for ProductListItemPurchase. The value of this property must be valid for the
 type of custom attribute defined for ProductListItemPurchase.

*/
func (a *Client) PostCustomersByIDProductListsByIDItemsByIDPurchases(params *PostCustomersByIDProductListsByIDItemsByIDPurchasesParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostCustomersByIDProductListsByIDItemsByIDPurchasesParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postCustomersByIDProductListsByIDItemsByIDPurchases",
		Method:             "POST",
		PathPattern:        "/customers/{customer_id}/product_lists/{list_id}/items/{item_id}/purchases",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PostCustomersByIDProductListsByIDItemsByIDPurchasesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PostCustomersPasswordReset First the beforePOST hook is called. After that the validation of the
 customer information provided in the the password reset document is performed.
 Then a password reset token is generated and together with the resolved
 customer is passed to a afterPOST hook. The customer resolution is based
 on the password reset request type. Both hooks are performed in a single
 transaction.
 Currently the resolution can be done by email or login. In case of
 an email the password reset hook is only executed if one and only one
 customer has been identified for that email. In the case that more than
 one customers have been identified for the provided email the resource
 does nothing.
*/
func (a *Client) PostCustomersPasswordReset(params *PostCustomersPasswordResetParams, authInfo runtime.ClientAuthInfoWriter) (*PostCustomersPasswordResetNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostCustomersPasswordResetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postCustomersPasswordReset",
		Method:             "POST",
		PathPattern:        "/customers/password_reset",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PostCustomersPasswordResetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostCustomersPasswordResetNoContent), nil

}

/*
PutCustomersByIDPassword Updates the customer's password.
*/
func (a *Client) PutCustomersByIDPassword(params *PutCustomersByIDPasswordParams, authInfo runtime.ClientAuthInfoWriter) (*PutCustomersByIDPasswordNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutCustomersByIDPasswordParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putCustomersByIDPassword",
		Method:             "PUT",
		PathPattern:        "/customers/{customer_id}/password",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PutCustomersByIDPasswordReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutCustomersByIDPasswordNoContent), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
