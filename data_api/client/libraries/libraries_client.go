// Code generated by go-swagger; DO NOT EDIT.

package libraries

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new libraries API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for libraries API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
DeleteLibrariesByIDContentByID Deletes the content asset with the specified ID from the specified library. If the content asset is not found, the server returns a 404 (NotFoundException) fault. If the content asset is locked by another user, the server returns a 409 (ResourceLockedException) fault. If the connection is not secure, the server returns a 403 (SecureCommunicationRequiredException) fault.
*/
func (a *Client) DeleteLibrariesByIDContentByID(params *DeleteLibrariesByIDContentByIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteLibrariesByIDContentByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteLibrariesByIDContentByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteLibrariesByIDContentByID",
		Method:             "DELETE",
		PathPattern:        "/libraries/{library_id}/content/{content_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteLibrariesByIDContentByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteLibrariesByIDContentByIDNoContent), nil

}

/*
DeleteLibrariesByIDFolderAssignmentsByIDByID Action to unassign a content asset from the specified library folder.
*/
func (a *Client) DeleteLibrariesByIDFolderAssignmentsByIDByID(params *DeleteLibrariesByIDFolderAssignmentsByIDByIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteLibrariesByIDFolderAssignmentsByIDByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteLibrariesByIDFolderAssignmentsByIDByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteLibrariesByIDFolderAssignmentsByIDByID",
		Method:             "DELETE",
		PathPattern:        "/libraries/{library_id}/folder_assignments/{content_id}/{folder_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteLibrariesByIDFolderAssignmentsByIDByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteLibrariesByIDFolderAssignmentsByIDByIDNoContent), nil

}

/*
DeleteLibrariesByIDFoldersByID Delete folder
*/
func (a *Client) DeleteLibrariesByIDFoldersByID(params *DeleteLibrariesByIDFoldersByIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteLibrariesByIDFoldersByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteLibrariesByIDFoldersByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteLibrariesByIDFoldersByID",
		Method:             "DELETE",
		PathPattern:        "/libraries/{library_id}/folders/{folder_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteLibrariesByIDFoldersByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteLibrariesByIDFoldersByIDNoContent), nil

}

/*
GetLibrariesByIDContentByID Returns a content asset using the specified ID. If the content asset cannot be found, the server returns a 404 (ContentNotFoundException) fault. If the connection is not secure, the server returns a 403 (SecureCommunicationRequiredException).
*/
func (a *Client) GetLibrariesByIDContentByID(params *GetLibrariesByIDContentByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLibrariesByIDContentByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getLibrariesByIDContentByID",
		Method:             "GET",
		PathPattern:        "/libraries/{library_id}/content/{content_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetLibrariesByIDContentByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetLibrariesByIDContentByIDFolders Action to get all assigned folders of a content asset.
*/
func (a *Client) GetLibrariesByIDContentByIDFolders(params *GetLibrariesByIDContentByIDFoldersParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLibrariesByIDContentByIDFoldersParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getLibrariesByIDContentByIDFolders",
		Method:             "GET",
		PathPattern:        "/libraries/{library_id}/content/{content_id}/folders",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetLibrariesByIDContentByIDFoldersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetLibrariesByIDFolderAssignmentsByIDByID Action to get a single content to folder assignment
*/
func (a *Client) GetLibrariesByIDFolderAssignmentsByIDByID(params *GetLibrariesByIDFolderAssignmentsByIDByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLibrariesByIDFolderAssignmentsByIDByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getLibrariesByIDFolderAssignmentsByIDByID",
		Method:             "GET",
		PathPattern:        "/libraries/{library_id}/folder_assignments/{content_id}/{folder_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetLibrariesByIDFolderAssignmentsByIDByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetLibrariesByIDFoldersByID Action to get folder information.
*/
func (a *Client) GetLibrariesByIDFoldersByID(params *GetLibrariesByIDFoldersByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLibrariesByIDFoldersByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getLibrariesByIDFoldersByID",
		Method:             "GET",
		PathPattern:        "/libraries/{library_id}/folders/{folder_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetLibrariesByIDFoldersByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetLibrariesByIDFoldersByIDContent Action to get all assigned content assets of a folder.
*/
func (a *Client) GetLibrariesByIDFoldersByIDContent(params *GetLibrariesByIDFoldersByIDContentParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLibrariesByIDFoldersByIDContentParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getLibrariesByIDFoldersByIDContent",
		Method:             "GET",
		PathPattern:        "/libraries/{library_id}/folders/{folder_id}/content",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetLibrariesByIDFoldersByIDContentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetLibrariesByIDFoldersByIDSubFolders Action to get sub folders information.
*/
func (a *Client) GetLibrariesByIDFoldersByIDSubFolders(params *GetLibrariesByIDFoldersByIDSubFoldersParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLibrariesByIDFoldersByIDSubFoldersParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getLibrariesByIDFoldersByIDSubFolders",
		Method:             "GET",
		PathPattern:        "/libraries/{library_id}/folders/{folder_id}/sub_folders",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetLibrariesByIDFoldersByIDSubFoldersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PatchLibrariesByIDContentByID Updates a content asset. In the request, the If-Match header is required. The value of the header is an 'ETag' representing the last known base-point information for the content asset. If the header is missing, the server returns a 409 (IfMatchRequiredException) fault. If the header value does not match the server's 'ETag', the server returns a 412 (InvalidIfMatchException) fault. The delta information for the library folder containing the content asset is updated atomically: the information is written completely or not at all. If the content asset is locked, the server returns a 409 (ResourceLockedException) fault.
*/
func (a *Client) PatchLibrariesByIDContentByID(params *PatchLibrariesByIDContentByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchLibrariesByIDContentByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchLibrariesByIDContentByID",
		Method:             "PATCH",
		PathPattern:        "/libraries/{library_id}/content/{content_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PatchLibrariesByIDContentByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PatchLibrariesByIDFolderAssignmentsByIDByID Action to update a single content to folder assignment. Currently only the position and default attribute can be changed.
*/
func (a *Client) PatchLibrariesByIDFolderAssignmentsByIDByID(params *PatchLibrariesByIDFolderAssignmentsByIDByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchLibrariesByIDFolderAssignmentsByIDByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchLibrariesByIDFolderAssignmentsByIDByID",
		Method:             "PATCH",
		PathPattern:        "/libraries/{library_id}/folder_assignments/{content_id}/{folder_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PatchLibrariesByIDFolderAssignmentsByIDByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PatchLibrariesByIDFoldersByID Updates an existing folder. In the request, the If-Match header is required. The value of the header is an 'ETag' representing the last known base-point information for the library folder. If the header is missing, the server returns a 409 (IfMatchRequiredException) fault. If the header value does not match the server's 'ETag', the server returns a 412 (InvalidIfMatchException) fault. The delta information for the library folder is updated atomically: the information is written completely or not at all.
*/
func (a *Client) PatchLibrariesByIDFoldersByID(params *PatchLibrariesByIDFoldersByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchLibrariesByIDFoldersByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchLibrariesByIDFoldersByID",
		Method:             "PATCH",
		PathPattern:        "/libraries/{library_id}/folders/{folder_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PatchLibrariesByIDFoldersByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PutLibrariesByIDContentByID Creates a new content asset in the specified library, or overwrites an existing content asset. If a content asset with the specified ID already exists, the server completely overwrites the content asset. Please note: Existing folder assignments are not touched. If the existing content asset is locked, the server returns a 409 (ResourceLockedException) fault. If the connection is not secure, the server returns a 403 (SecureCommunicationRequiredException) fault.
*/
func (a *Client) PutLibrariesByIDContentByID(params *PutLibrariesByIDContentByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutLibrariesByIDContentByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putLibrariesByIDContentByID",
		Method:             "PUT",
		PathPattern:        "/libraries/{library_id}/content/{content_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PutLibrariesByIDContentByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PutLibrariesByIDFolderAssignmentsByIDByID Action to assign a content asset to a specified folder.
*/
func (a *Client) PutLibrariesByIDFolderAssignmentsByIDByID(params *PutLibrariesByIDFolderAssignmentsByIDByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutLibrariesByIDFolderAssignmentsByIDByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putLibrariesByIDFolderAssignmentsByIDByID",
		Method:             "PUT",
		PathPattern:        "/libraries/{library_id}/folder_assignments/{content_id}/{folder_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PutLibrariesByIDFolderAssignmentsByIDByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PutLibrariesByIDFoldersByID Action to create a new library folder, or to replace an existing folder. This action completely overwrites existing folders. Please note: Sub folders and assignments to content assets are not touched. This action ignores the folder ID in the input document.
*/
func (a *Client) PutLibrariesByIDFoldersByID(params *PutLibrariesByIDFoldersByIDParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutLibrariesByIDFoldersByIDParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putLibrariesByIDFoldersByID",
		Method:             "PUT",
		PathPattern:        "/libraries/{library_id}/folders/{folder_id}",
		ProducesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "text/xml"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PutLibrariesByIDFoldersByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
