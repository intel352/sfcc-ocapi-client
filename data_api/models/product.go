// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Product Document representing a product
// swagger:model product
type Product struct {

	// The catalog categories that the product is assigned to
	AssignedCategories []*CatalogCategoryID `json:"assigned_categories"`

	// The ATS(Available To Sell) inventory value of the product. This is a calculated value.
	Ats float64 `json:"ats,omitempty"`

	// The brand of the product.
	Brand string `json:"brand,omitempty"`

	// The array of bundled products which the product includes.
	BundledProducts []*Product `json:"bundled_products"`

	// Signals if there are inventory lists for brick-and-mortar stores associated with this product.
	CAvailableForInStorePickup bool `json:"c_availableForInStorePickup,omitempty"`

	// c battery life
	CBatteryLife string `json:"c_batteryLife,omitempty"`

	// c battery type
	CBatteryType string `json:"c_batteryType,omitempty"`

	// Type of Boot for search refinement.
	CBootType []string `json:"c_bootType"`

	// Bottom type for search refinement
	CBottomType []string `json:"c_bottomType"`

	// Product color used for variation attribute
	CColor string `json:"c_color,omitempty"`

	// c console warranty
	CConsoleWarranty string `json:"c_consoleWarranty,omitempty"`

	// Use this attribute to apply custom styles for this product.
	CCustomCSSFile *MediaFile `json:"c_customCSSFile,omitempty"`

	// c digital camera features
	CDigitalCameraFeatures []string `json:"c_digitalCameraFeatures"`

	// c digital camera pixels
	CDigitalCameraPixels string `json:"c_digitalCameraPixels,omitempty"`

	// c digital camera type
	CDigitalCameraType string `json:"c_digitalCameraType,omitempty"`

	// c digital camera warranty
	CDigitalCameraWarranty string `json:"c_digitalCameraWarranty,omitempty"`

	// c dim depth
	CDimDepth string `json:"c_dimDepth,omitempty"`

	// c dim height
	CDimHeight string `json:"c_dimHeight,omitempty"`

	// c dim weight
	CDimWeight string `json:"c_dimWeight,omitempty"`

	// c dim width
	CDimWidth string `json:"c_dimWidth,omitempty"`

	// c display size
	CDisplaySize string `json:"c_displaySize,omitempty"`

	// c game genre
	CGameGenre []string `json:"c_gameGenre"`

	// c game rating
	CGameRating string `json:"c_gameRating,omitempty"`

	// c game system type
	CGameSystemType string `json:"c_gameSystemType,omitempty"`

	// c gps features
	CGpsFeatures []string `json:"c_gpsFeatures"`

	// c gps type
	CGpsType []string `json:"c_gpsType"`

	// c gps warranty
	CGpsWarranty string `json:"c_gpsWarranty,omitempty"`

	// c image aspect ratio
	CImageAspectRatio string `json:"c_imageAspectRatio,omitempty"`

	// c is new
	CIsNew bool `json:"c_isNew,omitempty"`

	// This indiciates if the product is a new arrival.
	CIsNewtest bool `json:"c_isNewtest,omitempty"`

	// This is the help text. It is used for sorting rules.
	CIsSale bool `json:"c_isSale,omitempty"`

	// Kids Age used for search refinements
	// Enum: [0010 0020 0030 0040 0050 0060 0070]
	CKidsAge string `json:"c_kidsAge,omitempty"`

	// This attribute is used for mens and womens pants lengths.
	CLength string `json:"c_length,omitempty"`

	// c lens aperture
	CLensAperture string `json:"c_lensAperture,omitempty"`

	// c material test
	CMaterialTest []string `json:"c_materialTest"`

	// Media Format
	CMediaFormat []string `json:"c_mediaFormat"`

	// Memory Size
	CMemorySize string `json:"c_memorySize,omitempty"`

	// c memory type
	CMemoryType []string `json:"c_memoryType"`

	// c music storage
	CMusicStorage string `json:"c_musicStorage,omitempty"`

	// c optical zoom
	COpticalZoom string `json:"c_opticalZoom,omitempty"`

	// Type of Outerwear for search refinement
	// Enum: [0010 0020 0030 0040 0050 0060 0070 0080]
	COuterwearType string `json:"c_outerwearType,omitempty"`

	// c portable audio type
	CPortableAudioType []string `json:"c_portableAudioType"`

	// c refinement color
	// Enum: [black blue green red orange pink purple white yellow grey beige miscellaneous brown navy]
	CRefinementColor string `json:"c_refinementColor,omitempty"`

	// c resolution
	CResolution string `json:"c_resolution,omitempty"`

	// Type of Sandal for search refinement
	// Enum: [0010 0020 0030]
	CSandalType string `json:"c_sandalType,omitempty"`

	// test attribute
	CSheets []string `json:"c_sheets"`

	// Type of Shoe for search refinements
	// Enum: [0010 0020 0030 0040 0050 0060 0070 0080 0090 0100 0110]
	CShoeType string `json:"c_shoeType,omitempty"`

	// This attribute is used for all footwear, apparel and accessory sizing for men, women and kids products.
	CSize string `json:"c_size,omitempty"`

	// c skin concern
	CSkinConcern []string `json:"c_skinConcern"`

	// c style number
	CStyleNumber string `json:"c_styleNumber,omitempty"`

	// c tab description
	CTabDescription *MarkupText `json:"c_tabDescription,omitempty"`

	// c tab details
	CTabDetails *MarkupText `json:"c_tabDetails,omitempty"`

	// c test
	CTest *MarkupText `json:"c_test,omitempty"`

	// Type of tops in clothing
	CTopType string `json:"c_topType,omitempty"`

	// c tv signal format
	CTvSignalFormat string `json:"c_tvSignalFormat,omitempty"`

	// c tv size
	CTvSize string `json:"c_tvSize,omitempty"`

	// c tv type
	// Enum: [0010 0020 0030 0040]
	CTvType string `json:"c_tvType,omitempty"`

	// c tv warranty
	CTvWarranty string `json:"c_tvWarranty,omitempty"`

	// c video storage
	CVideoStorage string `json:"c_videoStorage,omitempty"`

	// Attribute used for apparel waist sizing.
	CWaist string `json:"c_waist,omitempty"`

	// This attribute is used for shoe widths for mens, womens and kids.
	CWidth string `json:"c_width,omitempty"`

	// Returns the value of attribute 'creationDate'.
	// Read Only: true
	// Format: date-time
	CreationDate strfmt.DateTime `json:"creation_date,omitempty"`

	// The ID of the product's default variant.
	DefaultVariantID string `json:"default_variant_id,omitempty"`

	// The European Article Number of the product.
	Ean string `json:"ean,omitempty"`

	// The ID (SKU) of the product.
	// Required: true
	// Max Length: 100
	// Min Length: 1
	ID *string `json:"id"`

	// The image(s) assigned to the product.
	Image *MediaFile `json:"image,omitempty"`

	// The array of product image groups.
	ImageGroups []*ImageGroup `json:"image_groups"`

	// The flag that indicates if the product is in stock, or not. This is a calculated value.
	InStock bool `json:"in_stock,omitempty"`

	// Returns the value of attribute 'lastModified'.
	// Read Only: true
	// Format: date-time
	LastModified strfmt.DateTime `json:"last_modified,omitempty"`

	// A link to the product.
	Link string `json:"link,omitempty"`

	// The localized long description of the product.
	LongDescription map[string]MarkupText `json:"long_description,omitempty"`

	// The name of the product's manufacturer.
	ManufacturerName string `json:"manufacturer_name,omitempty"`

	// The SKU of the product's manufacturer.
	ManufacturerSku string `json:"manufacturer_sku,omitempty"`

	// The master of the product. This is applicable for product types "variation_group" and "variant" only.
	Master *Master `json:"master,omitempty"`

	// The localized name of the product.
	Name map[string]string `json:"name,omitempty"`

	// The flag that indicates if the product is online, or not. This is a calculated value.
	Online bool `json:"online,omitempty"`

	// The site specific online status of the product.
	OnlineFlag map[string]bool `json:"online_flag,omitempty"`

	// The ID of the catalog that owns the product.
	OwningCatalogID string `json:"owning_catalog_id,omitempty"`

	// The localized name of the catalog that owns the product.
	OwningCatalogName map[string]string `json:"owning_catalog_name,omitempty"`

	// The localized page description of the product.
	PageDescription map[string]string `json:"page_description,omitempty"`

	// The localized page keywords of the product.
	PageKeywords map[string]string `json:"page_keywords,omitempty"`

	// The localized page title of the product.
	PageTitle map[string]string `json:"page_title,omitempty"`

	// The price of the product.
	Price float64 `json:"price,omitempty"`

	// The currency code for product's price.
	PriceCurrency string `json:"price_currency,omitempty"`

	// The id of the products primary category.
	PrimaryCategoryID string `json:"primary_category_id,omitempty"`

	// The array of product bundles which the product belongs to.
	ProductBundles []*Product `json:"product_bundles"`

	// The array of product options. This is applicable for products of type "option".
	ProductOptions []*ProductOption `json:"product_options"`

	// The array of product sets which the product belongs to.
	ProductSets []*Product `json:"product_sets"`

	// The site specific searchable status of the product.
	Searchable map[string]bool `json:"searchable,omitempty"`

	// The array of set products which the product includes.
	SetProducts []*Product `json:"set_products"`

	// The localized short description of the product.
	ShortDescription map[string]MarkupText `json:"short_description,omitempty"`

	// The type of the product. It can have one or more of the values "item", "master", "variation_group", "variant", "bundle", and "set".
	Type *ProductType `json:"type,omitempty"`

	// The sales unit of the product.
	Unit string `json:"unit,omitempty"`

	// The Universal Product Code of the product.
	Upc string `json:"upc,omitempty"`

	// The array of variants of the product. This is applicable for product types "master" and "variation_group" only.
	Variants []*Variant `json:"variants"`

	// The sorted array of variation attributes assigned to the product. This is applicable for product types "master",
	//  "variation_group" and "variant" only.
	VariationAttributes []*VariationAttribute `json:"variation_attributes"`

	// The array of variation groups in the product. This is applicable for product type "master" only.
	VariationGroups []*VariationGroup `json:"variation_groups"`

	// The variation values selected for the product in variation attribute id and value pairs. This is applicable for product types "variant" and
	//  "variation_group" only.
	VariationValues map[string]string `json:"variation_values,omitempty"`
}

// Validate validates this product
func (m *Product) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAssignedCategories(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBundledProducts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCBootType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCBottomType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCCustomCSSFile(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCDigitalCameraFeatures(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCGameGenre(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCGpsFeatures(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCGpsType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCKidsAge(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCMaterialTest(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCMediaFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCMemoryType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCOuterwearType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCPortableAudioType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCRefinementColor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCSandalType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCSheets(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCShoeType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCSkinConcern(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCTabDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCTabDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCTest(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCTvType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImageGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastModified(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLongDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaster(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductBundles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductSets(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSetProducts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShortDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVariants(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVariationAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVariationGroups(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Product) validateAssignedCategories(formats strfmt.Registry) error {

	if swag.IsZero(m.AssignedCategories) { // not required
		return nil
	}

	for i := 0; i < len(m.AssignedCategories); i++ {
		if swag.IsZero(m.AssignedCategories[i]) { // not required
			continue
		}

		if m.AssignedCategories[i] != nil {
			if err := m.AssignedCategories[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("assigned_categories" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateBundledProducts(formats strfmt.Registry) error {

	if swag.IsZero(m.BundledProducts) { // not required
		return nil
	}

	for i := 0; i < len(m.BundledProducts); i++ {
		if swag.IsZero(m.BundledProducts[i]) { // not required
			continue
		}

		if m.BundledProducts[i] != nil {
			if err := m.BundledProducts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("bundled_products" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var productCBootTypeItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040","0050","0060","0070"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCBootTypeItemsEnum = append(productCBootTypeItemsEnum, v)
	}
}

func (m *Product) validateCBootTypeItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCBootTypeItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCBootType(formats strfmt.Registry) error {

	if swag.IsZero(m.CBootType) { // not required
		return nil
	}

	for i := 0; i < len(m.CBootType); i++ {

		// value enum
		if err := m.validateCBootTypeItemsEnum("c_bootType"+"."+strconv.Itoa(i), "body", m.CBootType[i]); err != nil {
			return err
		}

	}

	return nil
}

var productCBottomTypeItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040","0050","0060","0070","0080"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCBottomTypeItemsEnum = append(productCBottomTypeItemsEnum, v)
	}
}

func (m *Product) validateCBottomTypeItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCBottomTypeItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCBottomType(formats strfmt.Registry) error {

	if swag.IsZero(m.CBottomType) { // not required
		return nil
	}

	for i := 0; i < len(m.CBottomType); i++ {

		// value enum
		if err := m.validateCBottomTypeItemsEnum("c_bottomType"+"."+strconv.Itoa(i), "body", m.CBottomType[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *Product) validateCCustomCSSFile(formats strfmt.Registry) error {

	if swag.IsZero(m.CCustomCSSFile) { // not required
		return nil
	}

	if m.CCustomCSSFile != nil {
		if err := m.CCustomCSSFile.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("c_customCSSFile")
			}
			return err
		}
	}

	return nil
}

var productCDigitalCameraFeaturesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040","0050","0060","0070","0080","0090","0100","0110","0120","0130","0140","0150","0160","0170","0180","0190","0200","0210","0220","0230","0240","0250","0260","0270","0280"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCDigitalCameraFeaturesItemsEnum = append(productCDigitalCameraFeaturesItemsEnum, v)
	}
}

func (m *Product) validateCDigitalCameraFeaturesItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCDigitalCameraFeaturesItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCDigitalCameraFeatures(formats strfmt.Registry) error {

	if swag.IsZero(m.CDigitalCameraFeatures) { // not required
		return nil
	}

	for i := 0; i < len(m.CDigitalCameraFeatures); i++ {

		// value enum
		if err := m.validateCDigitalCameraFeaturesItemsEnum("c_digitalCameraFeatures"+"."+strconv.Itoa(i), "body", m.CDigitalCameraFeatures[i]); err != nil {
			return err
		}

	}

	return nil
}

var productCGameGenreItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Action","Educational","Kids","Racing","Role-Playing","Sports","Strategy"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCGameGenreItemsEnum = append(productCGameGenreItemsEnum, v)
	}
}

func (m *Product) validateCGameGenreItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCGameGenreItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCGameGenre(formats strfmt.Registry) error {

	if swag.IsZero(m.CGameGenre) { // not required
		return nil
	}

	for i := 0; i < len(m.CGameGenre); i++ {

		// value enum
		if err := m.validateCGameGenreItemsEnum("c_gameGenre"+"."+strconv.Itoa(i), "body", m.CGameGenre[i]); err != nil {
			return err
		}

	}

	return nil
}

var productCGpsFeaturesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040","0050","0060","0070","0080","0090","0100","0110","0120","0130","0140","0150","0160","0170","0180","0190","0200","0210","0230"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCGpsFeaturesItemsEnum = append(productCGpsFeaturesItemsEnum, v)
	}
}

func (m *Product) validateCGpsFeaturesItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCGpsFeaturesItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCGpsFeatures(formats strfmt.Registry) error {

	if swag.IsZero(m.CGpsFeatures) { // not required
		return nil
	}

	for i := 0; i < len(m.CGpsFeatures); i++ {

		// value enum
		if err := m.validateCGpsFeaturesItemsEnum("c_gpsFeatures"+"."+strconv.Itoa(i), "body", m.CGpsFeatures[i]); err != nil {
			return err
		}

	}

	return nil
}

var productCGpsTypeItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCGpsTypeItemsEnum = append(productCGpsTypeItemsEnum, v)
	}
}

func (m *Product) validateCGpsTypeItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCGpsTypeItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCGpsType(formats strfmt.Registry) error {

	if swag.IsZero(m.CGpsType) { // not required
		return nil
	}

	for i := 0; i < len(m.CGpsType); i++ {

		// value enum
		if err := m.validateCGpsTypeItemsEnum("c_gpsType"+"."+strconv.Itoa(i), "body", m.CGpsType[i]); err != nil {
			return err
		}

	}

	return nil
}

var productTypeCKidsAgePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040","0050","0060","0070"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productTypeCKidsAgePropEnum = append(productTypeCKidsAgePropEnum, v)
	}
}

const (

	// ProductCKidsAgeNr0010 captures enum value "0010"
	ProductCKidsAgeNr0010 string = "0010"

	// ProductCKidsAgeNr0020 captures enum value "0020"
	ProductCKidsAgeNr0020 string = "0020"

	// ProductCKidsAgeNr0030 captures enum value "0030"
	ProductCKidsAgeNr0030 string = "0030"

	// ProductCKidsAgeNr0040 captures enum value "0040"
	ProductCKidsAgeNr0040 string = "0040"

	// ProductCKidsAgeNr0050 captures enum value "0050"
	ProductCKidsAgeNr0050 string = "0050"

	// ProductCKidsAgeNr0060 captures enum value "0060"
	ProductCKidsAgeNr0060 string = "0060"

	// ProductCKidsAgeNr0070 captures enum value "0070"
	ProductCKidsAgeNr0070 string = "0070"
)

// prop value enum
func (m *Product) validateCKidsAgeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productTypeCKidsAgePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCKidsAge(formats strfmt.Registry) error {

	if swag.IsZero(m.CKidsAge) { // not required
		return nil
	}

	// value enum
	if err := m.validateCKidsAgeEnum("c_kidsAge", "body", m.CKidsAge); err != nil {
		return err
	}

	return nil
}

var productCMaterialTestItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["cotton","wool","polyester"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCMaterialTestItemsEnum = append(productCMaterialTestItemsEnum, v)
	}
}

func (m *Product) validateCMaterialTestItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCMaterialTestItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCMaterialTest(formats strfmt.Registry) error {

	if swag.IsZero(m.CMaterialTest) { // not required
		return nil
	}

	for i := 0; i < len(m.CMaterialTest); i++ {

		// value enum
		if err := m.validateCMaterialTestItemsEnum("c_materialTest"+"."+strconv.Itoa(i), "body", m.CMaterialTest[i]); err != nil {
			return err
		}

	}

	return nil
}

var productCMediaFormatItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040","0050","0060","0070","0080","0090","0100"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCMediaFormatItemsEnum = append(productCMediaFormatItemsEnum, v)
	}
}

func (m *Product) validateCMediaFormatItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCMediaFormatItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCMediaFormat(formats strfmt.Registry) error {

	if swag.IsZero(m.CMediaFormat) { // not required
		return nil
	}

	for i := 0; i < len(m.CMediaFormat); i++ {

		// value enum
		if err := m.validateCMediaFormatItemsEnum("c_mediaFormat"+"."+strconv.Itoa(i), "body", m.CMediaFormat[i]); err != nil {
			return err
		}

	}

	return nil
}

var productCMemoryTypeItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040","0050","0060","0070","0080","0090"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCMemoryTypeItemsEnum = append(productCMemoryTypeItemsEnum, v)
	}
}

func (m *Product) validateCMemoryTypeItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCMemoryTypeItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCMemoryType(formats strfmt.Registry) error {

	if swag.IsZero(m.CMemoryType) { // not required
		return nil
	}

	for i := 0; i < len(m.CMemoryType); i++ {

		// value enum
		if err := m.validateCMemoryTypeItemsEnum("c_memoryType"+"."+strconv.Itoa(i), "body", m.CMemoryType[i]); err != nil {
			return err
		}

	}

	return nil
}

var productTypeCOuterwearTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040","0050","0060","0070","0080"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productTypeCOuterwearTypePropEnum = append(productTypeCOuterwearTypePropEnum, v)
	}
}

const (

	// ProductCOuterwearTypeNr0010 captures enum value "0010"
	ProductCOuterwearTypeNr0010 string = "0010"

	// ProductCOuterwearTypeNr0020 captures enum value "0020"
	ProductCOuterwearTypeNr0020 string = "0020"

	// ProductCOuterwearTypeNr0030 captures enum value "0030"
	ProductCOuterwearTypeNr0030 string = "0030"

	// ProductCOuterwearTypeNr0040 captures enum value "0040"
	ProductCOuterwearTypeNr0040 string = "0040"

	// ProductCOuterwearTypeNr0050 captures enum value "0050"
	ProductCOuterwearTypeNr0050 string = "0050"

	// ProductCOuterwearTypeNr0060 captures enum value "0060"
	ProductCOuterwearTypeNr0060 string = "0060"

	// ProductCOuterwearTypeNr0070 captures enum value "0070"
	ProductCOuterwearTypeNr0070 string = "0070"

	// ProductCOuterwearTypeNr0080 captures enum value "0080"
	ProductCOuterwearTypeNr0080 string = "0080"
)

// prop value enum
func (m *Product) validateCOuterwearTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productTypeCOuterwearTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCOuterwearType(formats strfmt.Registry) error {

	if swag.IsZero(m.COuterwearType) { // not required
		return nil
	}

	// value enum
	if err := m.validateCOuterwearTypeEnum("c_outerwearType", "body", m.COuterwearType); err != nil {
		return err
	}

	return nil
}

var productCPortableAudioTypeItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCPortableAudioTypeItemsEnum = append(productCPortableAudioTypeItemsEnum, v)
	}
}

func (m *Product) validateCPortableAudioTypeItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCPortableAudioTypeItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCPortableAudioType(formats strfmt.Registry) error {

	if swag.IsZero(m.CPortableAudioType) { // not required
		return nil
	}

	for i := 0; i < len(m.CPortableAudioType); i++ {

		// value enum
		if err := m.validateCPortableAudioTypeItemsEnum("c_portableAudioType"+"."+strconv.Itoa(i), "body", m.CPortableAudioType[i]); err != nil {
			return err
		}

	}

	return nil
}

var productTypeCRefinementColorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["black","blue","green","red","orange","pink","purple","white","yellow","grey","beige","miscellaneous","brown","navy"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productTypeCRefinementColorPropEnum = append(productTypeCRefinementColorPropEnum, v)
	}
}

const (

	// ProductCRefinementColorBlack captures enum value "black"
	ProductCRefinementColorBlack string = "black"

	// ProductCRefinementColorBlue captures enum value "blue"
	ProductCRefinementColorBlue string = "blue"

	// ProductCRefinementColorGreen captures enum value "green"
	ProductCRefinementColorGreen string = "green"

	// ProductCRefinementColorRed captures enum value "red"
	ProductCRefinementColorRed string = "red"

	// ProductCRefinementColorOrange captures enum value "orange"
	ProductCRefinementColorOrange string = "orange"

	// ProductCRefinementColorPink captures enum value "pink"
	ProductCRefinementColorPink string = "pink"

	// ProductCRefinementColorPurple captures enum value "purple"
	ProductCRefinementColorPurple string = "purple"

	// ProductCRefinementColorWhite captures enum value "white"
	ProductCRefinementColorWhite string = "white"

	// ProductCRefinementColorYellow captures enum value "yellow"
	ProductCRefinementColorYellow string = "yellow"

	// ProductCRefinementColorGrey captures enum value "grey"
	ProductCRefinementColorGrey string = "grey"

	// ProductCRefinementColorBeige captures enum value "beige"
	ProductCRefinementColorBeige string = "beige"

	// ProductCRefinementColorMiscellaneous captures enum value "miscellaneous"
	ProductCRefinementColorMiscellaneous string = "miscellaneous"

	// ProductCRefinementColorBrown captures enum value "brown"
	ProductCRefinementColorBrown string = "brown"

	// ProductCRefinementColorNavy captures enum value "navy"
	ProductCRefinementColorNavy string = "navy"
)

// prop value enum
func (m *Product) validateCRefinementColorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productTypeCRefinementColorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCRefinementColor(formats strfmt.Registry) error {

	if swag.IsZero(m.CRefinementColor) { // not required
		return nil
	}

	// value enum
	if err := m.validateCRefinementColorEnum("c_refinementColor", "body", m.CRefinementColor); err != nil {
		return err
	}

	return nil
}

var productTypeCSandalTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productTypeCSandalTypePropEnum = append(productTypeCSandalTypePropEnum, v)
	}
}

const (

	// ProductCSandalTypeNr0010 captures enum value "0010"
	ProductCSandalTypeNr0010 string = "0010"

	// ProductCSandalTypeNr0020 captures enum value "0020"
	ProductCSandalTypeNr0020 string = "0020"

	// ProductCSandalTypeNr0030 captures enum value "0030"
	ProductCSandalTypeNr0030 string = "0030"
)

// prop value enum
func (m *Product) validateCSandalTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productTypeCSandalTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCSandalType(formats strfmt.Registry) error {

	if swag.IsZero(m.CSandalType) { // not required
		return nil
	}

	// value enum
	if err := m.validateCSandalTypeEnum("c_sandalType", "body", m.CSandalType); err != nil {
		return err
	}

	return nil
}

var productCSheetsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["value1","value2","value3"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCSheetsItemsEnum = append(productCSheetsItemsEnum, v)
	}
}

func (m *Product) validateCSheetsItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCSheetsItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCSheets(formats strfmt.Registry) error {

	if swag.IsZero(m.CSheets) { // not required
		return nil
	}

	for i := 0; i < len(m.CSheets); i++ {

		// value enum
		if err := m.validateCSheetsItemsEnum("c_sheets"+"."+strconv.Itoa(i), "body", m.CSheets[i]); err != nil {
			return err
		}

	}

	return nil
}

var productTypeCShoeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040","0050","0060","0070","0080","0090","0100","0110"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productTypeCShoeTypePropEnum = append(productTypeCShoeTypePropEnum, v)
	}
}

const (

	// ProductCShoeTypeNr0010 captures enum value "0010"
	ProductCShoeTypeNr0010 string = "0010"

	// ProductCShoeTypeNr0020 captures enum value "0020"
	ProductCShoeTypeNr0020 string = "0020"

	// ProductCShoeTypeNr0030 captures enum value "0030"
	ProductCShoeTypeNr0030 string = "0030"

	// ProductCShoeTypeNr0040 captures enum value "0040"
	ProductCShoeTypeNr0040 string = "0040"

	// ProductCShoeTypeNr0050 captures enum value "0050"
	ProductCShoeTypeNr0050 string = "0050"

	// ProductCShoeTypeNr0060 captures enum value "0060"
	ProductCShoeTypeNr0060 string = "0060"

	// ProductCShoeTypeNr0070 captures enum value "0070"
	ProductCShoeTypeNr0070 string = "0070"

	// ProductCShoeTypeNr0080 captures enum value "0080"
	ProductCShoeTypeNr0080 string = "0080"

	// ProductCShoeTypeNr0090 captures enum value "0090"
	ProductCShoeTypeNr0090 string = "0090"

	// ProductCShoeTypeNr0100 captures enum value "0100"
	ProductCShoeTypeNr0100 string = "0100"

	// ProductCShoeTypeNr0110 captures enum value "0110"
	ProductCShoeTypeNr0110 string = "0110"
)

// prop value enum
func (m *Product) validateCShoeTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productTypeCShoeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCShoeType(formats strfmt.Registry) error {

	if swag.IsZero(m.CShoeType) { // not required
		return nil
	}

	// value enum
	if err := m.validateCShoeTypeEnum("c_shoeType", "body", m.CShoeType); err != nil {
		return err
	}

	return nil
}

var productCSkinConcernItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["dryTight","comprehensive","liftingLossFirm"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productCSkinConcernItemsEnum = append(productCSkinConcernItemsEnum, v)
	}
}

func (m *Product) validateCSkinConcernItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productCSkinConcernItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCSkinConcern(formats strfmt.Registry) error {

	if swag.IsZero(m.CSkinConcern) { // not required
		return nil
	}

	for i := 0; i < len(m.CSkinConcern); i++ {

		// value enum
		if err := m.validateCSkinConcernItemsEnum("c_skinConcern"+"."+strconv.Itoa(i), "body", m.CSkinConcern[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *Product) validateCTabDescription(formats strfmt.Registry) error {

	if swag.IsZero(m.CTabDescription) { // not required
		return nil
	}

	if m.CTabDescription != nil {
		if err := m.CTabDescription.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("c_tabDescription")
			}
			return err
		}
	}

	return nil
}

func (m *Product) validateCTabDetails(formats strfmt.Registry) error {

	if swag.IsZero(m.CTabDetails) { // not required
		return nil
	}

	if m.CTabDetails != nil {
		if err := m.CTabDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("c_tabDetails")
			}
			return err
		}
	}

	return nil
}

func (m *Product) validateCTest(formats strfmt.Registry) error {

	if swag.IsZero(m.CTest) { // not required
		return nil
	}

	if m.CTest != nil {
		if err := m.CTest.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("c_test")
			}
			return err
		}
	}

	return nil
}

var productTypeCTvTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["0010","0020","0030","0040"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		productTypeCTvTypePropEnum = append(productTypeCTvTypePropEnum, v)
	}
}

const (

	// ProductCTvTypeNr0010 captures enum value "0010"
	ProductCTvTypeNr0010 string = "0010"

	// ProductCTvTypeNr0020 captures enum value "0020"
	ProductCTvTypeNr0020 string = "0020"

	// ProductCTvTypeNr0030 captures enum value "0030"
	ProductCTvTypeNr0030 string = "0030"

	// ProductCTvTypeNr0040 captures enum value "0040"
	ProductCTvTypeNr0040 string = "0040"
)

// prop value enum
func (m *Product) validateCTvTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, productTypeCTvTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Product) validateCTvType(formats strfmt.Registry) error {

	if swag.IsZero(m.CTvType) { // not required
		return nil
	}

	// value enum
	if err := m.validateCTvTypeEnum("c_tvType", "body", m.CTvType); err != nil {
		return err
	}

	return nil
}

func (m *Product) validateCreationDate(formats strfmt.Registry) error {

	if swag.IsZero(m.CreationDate) { // not required
		return nil
	}

	if err := validate.FormatOf("creation_date", "body", "date-time", m.CreationDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Product) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	if err := validate.MinLength("id", "body", string(*m.ID), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("id", "body", string(*m.ID), 100); err != nil {
		return err
	}

	return nil
}

func (m *Product) validateImage(formats strfmt.Registry) error {

	if swag.IsZero(m.Image) { // not required
		return nil
	}

	if m.Image != nil {
		if err := m.Image.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("image")
			}
			return err
		}
	}

	return nil
}

func (m *Product) validateImageGroups(formats strfmt.Registry) error {

	if swag.IsZero(m.ImageGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.ImageGroups); i++ {
		if swag.IsZero(m.ImageGroups[i]) { // not required
			continue
		}

		if m.ImageGroups[i] != nil {
			if err := m.ImageGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("image_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateLastModified(formats strfmt.Registry) error {

	if swag.IsZero(m.LastModified) { // not required
		return nil
	}

	if err := validate.FormatOf("last_modified", "body", "date-time", m.LastModified.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Product) validateLongDescription(formats strfmt.Registry) error {

	if swag.IsZero(m.LongDescription) { // not required
		return nil
	}

	for k := range m.LongDescription {

		if err := validate.Required("long_description"+"."+k, "body", m.LongDescription[k]); err != nil {
			return err
		}
		if val, ok := m.LongDescription[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateMaster(formats strfmt.Registry) error {

	if swag.IsZero(m.Master) { // not required
		return nil
	}

	if m.Master != nil {
		if err := m.Master.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("master")
			}
			return err
		}
	}

	return nil
}

func (m *Product) validateProductBundles(formats strfmt.Registry) error {

	if swag.IsZero(m.ProductBundles) { // not required
		return nil
	}

	for i := 0; i < len(m.ProductBundles); i++ {
		if swag.IsZero(m.ProductBundles[i]) { // not required
			continue
		}

		if m.ProductBundles[i] != nil {
			if err := m.ProductBundles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("product_bundles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateProductOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.ProductOptions) { // not required
		return nil
	}

	for i := 0; i < len(m.ProductOptions); i++ {
		if swag.IsZero(m.ProductOptions[i]) { // not required
			continue
		}

		if m.ProductOptions[i] != nil {
			if err := m.ProductOptions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("product_options" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateProductSets(formats strfmt.Registry) error {

	if swag.IsZero(m.ProductSets) { // not required
		return nil
	}

	for i := 0; i < len(m.ProductSets); i++ {
		if swag.IsZero(m.ProductSets[i]) { // not required
			continue
		}

		if m.ProductSets[i] != nil {
			if err := m.ProductSets[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("product_sets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateSetProducts(formats strfmt.Registry) error {

	if swag.IsZero(m.SetProducts) { // not required
		return nil
	}

	for i := 0; i < len(m.SetProducts); i++ {
		if swag.IsZero(m.SetProducts[i]) { // not required
			continue
		}

		if m.SetProducts[i] != nil {
			if err := m.SetProducts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("set_products" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateShortDescription(formats strfmt.Registry) error {

	if swag.IsZero(m.ShortDescription) { // not required
		return nil
	}

	for k := range m.ShortDescription {

		if err := validate.Required("short_description"+"."+k, "body", m.ShortDescription[k]); err != nil {
			return err
		}
		if val, ok := m.ShortDescription[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	if m.Type != nil {
		if err := m.Type.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

func (m *Product) validateVariants(formats strfmt.Registry) error {

	if swag.IsZero(m.Variants) { // not required
		return nil
	}

	for i := 0; i < len(m.Variants); i++ {
		if swag.IsZero(m.Variants[i]) { // not required
			continue
		}

		if m.Variants[i] != nil {
			if err := m.Variants[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("variants" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateVariationAttributes(formats strfmt.Registry) error {

	if swag.IsZero(m.VariationAttributes) { // not required
		return nil
	}

	for i := 0; i < len(m.VariationAttributes); i++ {
		if swag.IsZero(m.VariationAttributes[i]) { // not required
			continue
		}

		if m.VariationAttributes[i] != nil {
			if err := m.VariationAttributes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("variation_attributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Product) validateVariationGroups(formats strfmt.Registry) error {

	if swag.IsZero(m.VariationGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.VariationGroups); i++ {
		if swag.IsZero(m.VariationGroups[i]) { // not required
			continue
		}

		if m.VariationGroups[i] != nil {
			if err := m.VariationGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("variation_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Product) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Product) UnmarshalBinary(b []byte) error {
	var res Product
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
