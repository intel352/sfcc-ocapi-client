// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ObjectAttributeDefinition Document representing a attribute definition
// swagger:model object_attribute_definition
type ObjectAttributeDefinition struct {

	// The default value of this attribute. It can be updated, but not created.
	DefaultValue *ObjectAttributeValueDefinition `json:"default_value,omitempty"`

	// The localized description of the attribute.
	Description map[string]string `json:"description,omitempty"`

	// The localized name presented to the user in forms.
	DisplayName map[string]string `json:"display_name,omitempty"`

	// The effective ID, which is c_id if the attribute is custom, and just the id otherwise. It is read only.
	EffectiveID string `json:"effective_id,omitempty"`

	// Flag indicating if this attribute is externally defined.
	ExternallyDefined bool `json:"externally_defined,omitempty"`

	// Flag indicating if this attribute is externally managed.
	ExternallyManaged bool `json:"externally_managed,omitempty"`

	// The height of the field for this attribute in the editor.
	FieldHeight int32 `json:"field_height,omitempty"`

	// The length of the field for this attribute in the editor.
	FieldLength int32 `json:"field_length,omitempty"`

	// The user supplied ID of the attribute.
	ID string `json:"id,omitempty"`

	// Flag indicating if this is a key attribute.
	Key bool `json:"key,omitempty"`

	// The URL that is used to get this instance.  Value is computed and read-only.
	Link string `json:"link,omitempty"`

	// Flag indicating if this attribute can be localized.
	Localizable bool `json:"localizable,omitempty"`

	// Flag indicating if a value is mandatory for the attribute.
	Mandatory bool `json:"mandatory,omitempty"`

	// The maximum possible value for this attribute.
	MaxValue float64 `json:"max_value,omitempty"`

	// The minimum length of the field for this attribute.
	MinLength int32 `json:"min_length,omitempty"`

	// The minimum possible value for this attribute.
	MinValue float64 `json:"min_value,omitempty"`

	// True if the attribute can have multiple values.
	//  Attributes of the following types are multi-value capable:
	//
	//  set_of_int
	//  set_of_number
	//  set_of_string
	//
	//  Additionally, attributes of the following types can be multi-value
	//  enabled:
	//
	//  enum_of_int
	//  enum_of_string
	//
	MultiValueType bool `json:"multi_value_type,omitempty"`

	// Flag indicating if this attribute is required for order of the attribute model's product. The set of these can be used
	//  in order line items.
	OrderRequired bool `json:"order_required,omitempty"`

	// Returns true if the attribute definition is explicitly marked queryable. If no explicit queryable is found
	//  and the attribute value type belongs to a queryable type, true is returned too. In all other cases false is returned.
	//  Value is computed and read-only.
	Queryable bool `json:"queryable,omitempty"`

	// Flag indicating if this attribute is read-only. It is read only.
	ReadOnly bool `json:"read_only,omitempty"`

	// A regular expression that defines the legal values for this attribute.
	RegularExpression string `json:"regular_expression,omitempty"`

	// Flag indicating if this attribute can be encoded using the encoding="off" flag in ISML templates. It is read only.
	RequiresEncoding bool `json:"requires_encoding,omitempty"`

	// The minimum number of fraction digits for a value of this attribute.
	Scale int32 `json:"scale,omitempty"`

	// Flag indicating if this attribute is searchable.
	Searchable bool `json:"searchable,omitempty"`

	// Flag indicating if this attribute is of type 'Set of'. It is read only.
	SetValueType bool `json:"set_value_type,omitempty"`

	// Flag indicating if this attribute is site-specific.
	SiteSpecific bool `json:"site_specific,omitempty"`

	// Flag indicating if this attribute is a system attribute.
	System bool `json:"system,omitempty"`

	// The unit of measure for this attribute.
	Unit map[string]string `json:"unit,omitempty"`

	// A set of values that are possible for this attribute. It is read only.
	ValueDefinitions []*ObjectAttributeValueDefinition `json:"value_definitions"`

	// The type of this attribute.
	// Enum: [string int double text html date image boolean money quantity datetime email password set_of_string set_of_int set_of_double enum_of_string enum_of_int unknown]
	ValueType string `json:"value_type,omitempty"`

	// Flag indicating if this attribute is visible.
	Visible bool `json:"visible,omitempty"`
}

// Validate validates this object attribute definition
func (m *ObjectAttributeDefinition) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDefaultValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValueDefinitions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValueType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ObjectAttributeDefinition) validateDefaultValue(formats strfmt.Registry) error {

	if swag.IsZero(m.DefaultValue) { // not required
		return nil
	}

	if m.DefaultValue != nil {
		if err := m.DefaultValue.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("default_value")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectAttributeDefinition) validateValueDefinitions(formats strfmt.Registry) error {

	if swag.IsZero(m.ValueDefinitions) { // not required
		return nil
	}

	for i := 0; i < len(m.ValueDefinitions); i++ {
		if swag.IsZero(m.ValueDefinitions[i]) { // not required
			continue
		}

		if m.ValueDefinitions[i] != nil {
			if err := m.ValueDefinitions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("value_definitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var objectAttributeDefinitionTypeValueTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["string","int","double","text","html","date","image","boolean","money","quantity","datetime","email","password","set_of_string","set_of_int","set_of_double","enum_of_string","enum_of_int","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		objectAttributeDefinitionTypeValueTypePropEnum = append(objectAttributeDefinitionTypeValueTypePropEnum, v)
	}
}

const (

	// ObjectAttributeDefinitionValueTypeString captures enum value "string"
	ObjectAttributeDefinitionValueTypeString string = "string"

	// ObjectAttributeDefinitionValueTypeInt captures enum value "int"
	ObjectAttributeDefinitionValueTypeInt string = "int"

	// ObjectAttributeDefinitionValueTypeDouble captures enum value "double"
	ObjectAttributeDefinitionValueTypeDouble string = "double"

	// ObjectAttributeDefinitionValueTypeText captures enum value "text"
	ObjectAttributeDefinitionValueTypeText string = "text"

	// ObjectAttributeDefinitionValueTypeHTML captures enum value "html"
	ObjectAttributeDefinitionValueTypeHTML string = "html"

	// ObjectAttributeDefinitionValueTypeDate captures enum value "date"
	ObjectAttributeDefinitionValueTypeDate string = "date"

	// ObjectAttributeDefinitionValueTypeImage captures enum value "image"
	ObjectAttributeDefinitionValueTypeImage string = "image"

	// ObjectAttributeDefinitionValueTypeBoolean captures enum value "boolean"
	ObjectAttributeDefinitionValueTypeBoolean string = "boolean"

	// ObjectAttributeDefinitionValueTypeMoney captures enum value "money"
	ObjectAttributeDefinitionValueTypeMoney string = "money"

	// ObjectAttributeDefinitionValueTypeQuantity captures enum value "quantity"
	ObjectAttributeDefinitionValueTypeQuantity string = "quantity"

	// ObjectAttributeDefinitionValueTypeDatetime captures enum value "datetime"
	ObjectAttributeDefinitionValueTypeDatetime string = "datetime"

	// ObjectAttributeDefinitionValueTypeEmail captures enum value "email"
	ObjectAttributeDefinitionValueTypeEmail string = "email"

	// ObjectAttributeDefinitionValueTypePassword captures enum value "password"
	ObjectAttributeDefinitionValueTypePassword string = "password"

	// ObjectAttributeDefinitionValueTypeSetOfString captures enum value "set_of_string"
	ObjectAttributeDefinitionValueTypeSetOfString string = "set_of_string"

	// ObjectAttributeDefinitionValueTypeSetOfInt captures enum value "set_of_int"
	ObjectAttributeDefinitionValueTypeSetOfInt string = "set_of_int"

	// ObjectAttributeDefinitionValueTypeSetOfDouble captures enum value "set_of_double"
	ObjectAttributeDefinitionValueTypeSetOfDouble string = "set_of_double"

	// ObjectAttributeDefinitionValueTypeEnumOfString captures enum value "enum_of_string"
	ObjectAttributeDefinitionValueTypeEnumOfString string = "enum_of_string"

	// ObjectAttributeDefinitionValueTypeEnumOfInt captures enum value "enum_of_int"
	ObjectAttributeDefinitionValueTypeEnumOfInt string = "enum_of_int"

	// ObjectAttributeDefinitionValueTypeUnknown captures enum value "unknown"
	ObjectAttributeDefinitionValueTypeUnknown string = "unknown"
)

// prop value enum
func (m *ObjectAttributeDefinition) validateValueTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, objectAttributeDefinitionTypeValueTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ObjectAttributeDefinition) validateValueType(formats strfmt.Registry) error {

	if swag.IsZero(m.ValueType) { // not required
		return nil
	}

	// value enum
	if err := m.validateValueTypeEnum("value_type", "body", m.ValueType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ObjectAttributeDefinition) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ObjectAttributeDefinition) UnmarshalBinary(b []byte) error {
	var res ObjectAttributeDefinition
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
