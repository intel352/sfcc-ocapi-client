// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PreferenceValue Represents a single preference value
// swagger:model preference_value
type PreferenceValue struct {

	// The attribute definition for this preference
	AttributeDefinition *ObjectAttributeDefinition `json:"attribute_definition,omitempty"`

	// Description of the attribute
	Description map[string]string `json:"description,omitempty"`

	// Display name for the attribute
	DisplayName map[string]string `json:"display_name,omitempty"`

	// The id of the attribute
	ID string `json:"id,omitempty"`

	// The value of this attribute
	SiteValues map[string]interface{} `json:"site_values,omitempty"`

	// The type of this attribute.
	// Enum: [string int double text html date image boolean money quantity datetime email password set_of_string set_of_int set_of_double enum_of_string enum_of_int unknown]
	ValueType string `json:"value_type,omitempty"`
}

// Validate validates this preference value
func (m *PreferenceValue) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttributeDefinition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValueType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PreferenceValue) validateAttributeDefinition(formats strfmt.Registry) error {

	if swag.IsZero(m.AttributeDefinition) { // not required
		return nil
	}

	if m.AttributeDefinition != nil {
		if err := m.AttributeDefinition.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attribute_definition")
			}
			return err
		}
	}

	return nil
}

var preferenceValueTypeValueTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["string","int","double","text","html","date","image","boolean","money","quantity","datetime","email","password","set_of_string","set_of_int","set_of_double","enum_of_string","enum_of_int","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		preferenceValueTypeValueTypePropEnum = append(preferenceValueTypeValueTypePropEnum, v)
	}
}

const (

	// PreferenceValueValueTypeString captures enum value "string"
	PreferenceValueValueTypeString string = "string"

	// PreferenceValueValueTypeInt captures enum value "int"
	PreferenceValueValueTypeInt string = "int"

	// PreferenceValueValueTypeDouble captures enum value "double"
	PreferenceValueValueTypeDouble string = "double"

	// PreferenceValueValueTypeText captures enum value "text"
	PreferenceValueValueTypeText string = "text"

	// PreferenceValueValueTypeHTML captures enum value "html"
	PreferenceValueValueTypeHTML string = "html"

	// PreferenceValueValueTypeDate captures enum value "date"
	PreferenceValueValueTypeDate string = "date"

	// PreferenceValueValueTypeImage captures enum value "image"
	PreferenceValueValueTypeImage string = "image"

	// PreferenceValueValueTypeBoolean captures enum value "boolean"
	PreferenceValueValueTypeBoolean string = "boolean"

	// PreferenceValueValueTypeMoney captures enum value "money"
	PreferenceValueValueTypeMoney string = "money"

	// PreferenceValueValueTypeQuantity captures enum value "quantity"
	PreferenceValueValueTypeQuantity string = "quantity"

	// PreferenceValueValueTypeDatetime captures enum value "datetime"
	PreferenceValueValueTypeDatetime string = "datetime"

	// PreferenceValueValueTypeEmail captures enum value "email"
	PreferenceValueValueTypeEmail string = "email"

	// PreferenceValueValueTypePassword captures enum value "password"
	PreferenceValueValueTypePassword string = "password"

	// PreferenceValueValueTypeSetOfString captures enum value "set_of_string"
	PreferenceValueValueTypeSetOfString string = "set_of_string"

	// PreferenceValueValueTypeSetOfInt captures enum value "set_of_int"
	PreferenceValueValueTypeSetOfInt string = "set_of_int"

	// PreferenceValueValueTypeSetOfDouble captures enum value "set_of_double"
	PreferenceValueValueTypeSetOfDouble string = "set_of_double"

	// PreferenceValueValueTypeEnumOfString captures enum value "enum_of_string"
	PreferenceValueValueTypeEnumOfString string = "enum_of_string"

	// PreferenceValueValueTypeEnumOfInt captures enum value "enum_of_int"
	PreferenceValueValueTypeEnumOfInt string = "enum_of_int"

	// PreferenceValueValueTypeUnknown captures enum value "unknown"
	PreferenceValueValueTypeUnknown string = "unknown"
)

// prop value enum
func (m *PreferenceValue) validateValueTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, preferenceValueTypeValueTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *PreferenceValue) validateValueType(formats strfmt.Registry) error {

	if swag.IsZero(m.ValueType) { // not required
		return nil
	}

	// value enum
	if err := m.validateValueTypeEnum("value_type", "body", m.ValueType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PreferenceValue) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PreferenceValue) UnmarshalBinary(b []byte) error {
	var res PreferenceValue
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
