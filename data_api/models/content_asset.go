// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ContentAsset Document representing a content asset.
// swagger:model content_asset
type ContentAsset struct {

	// c year
	CYear string `json:"c_Year,omitempty"`

	// c body
	CBody map[string]MarkupText `json:"c_body,omitempty"`

	// Use this attribute to apply custom styles for this content asset.
	CCustomCSSFile *MediaFile `json:"c_customCSSFile,omitempty"`

	// The ID of the classification folder. It is only part of the response, if the assignment from  this content asset to the folder is marked as 'default'. The property is read-only. To  set the classification folder just create/update an assignment between this content asset and  a folder and mark it as 'default'. See details in  /libraries/{library_id}/folder_assignments/{content_id}/{folder_id} resource.
	ClassificationFolderID string `json:"classification_folder_id,omitempty"`

	// The link to the classification folder. It is only part of the response, if the assignment from  this content asset to the folder is marked as 'default'. The property is read-only. To  set the classification folder just create/update an assignment between this content asset and  a folder and mark it as 'default'. See details in  /libraries/{library_id}/folder_assignments/{content_id}/{folder_id} resource.
	ClassificationFolderLink string `json:"classification_folder_link,omitempty"`

	// Returns the value of attribute 'creationDate'.
	// Read Only: true
	// Format: date-time
	CreationDate strfmt.DateTime `json:"creation_date,omitempty"`

	// The localized content asset description.
	Description map[string]string `json:"description,omitempty"`

	// The id of the content asset.
	// Required: true
	// Max Length: 256
	// Min Length: 1
	ID *string `json:"id"`

	// Returns the value of attribute 'lastModified'.
	// Read Only: true
	// Format: date-time
	LastModified strfmt.DateTime `json:"last_modified,omitempty"`

	// The link to the content asset resource.
	Link string `json:"link,omitempty"`

	// The localized content asset name.
	Name map[string]string `json:"name,omitempty"`

	// Is the asset online?
	Online map[string]bool `json:"online,omitempty"`

	// The localized content asset page description.
	PageDescription map[string]string `json:"page_description,omitempty"`

	// The localized content asset page keywords.
	PageKeywords map[string]string `json:"page_keywords,omitempty"`

	// The localized content asset page title.
	PageTitle map[string]string `json:"page_title,omitempty"`

	// The localized content asset page url.
	PageURL map[string]string `json:"page_url,omitempty"`

	// Is the asset searchable?
	Searchable map[string]bool `json:"searchable,omitempty"`

	// The content assets change frequency needed for the sitemap creation  (always, hourly, daily, weekly, monthly, yearly, never).
	SiteMapChangeFrequency map[string]string `json:"site_map_change_frequency,omitempty"`

	// The status if the content asset is included into the sitemap (either 0 or  1).
	SiteMapIncluded map[string]*int32 `json:"site_map_included,omitempty"`

	// The content assets priority needed for the sitemap creation (0.0 for no  priority defined).
	SiteMapPriority map[string]float64 `json:"site_map_priority,omitempty"`

	// The rendering template.
	Template string `json:"template,omitempty"`
}

// Validate validates this content asset
func (m *ContentAsset) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCBody(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCCustomCSSFile(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastModified(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSiteMapChangeFrequency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSiteMapIncluded(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSiteMapPriority(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ContentAsset) validateCBody(formats strfmt.Registry) error {

	if swag.IsZero(m.CBody) { // not required
		return nil
	}

	for k := range m.CBody {

		if err := validate.Required("c_body"+"."+k, "body", m.CBody[k]); err != nil {
			return err
		}
		if val, ok := m.CBody[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ContentAsset) validateCCustomCSSFile(formats strfmt.Registry) error {

	if swag.IsZero(m.CCustomCSSFile) { // not required
		return nil
	}

	if m.CCustomCSSFile != nil {
		if err := m.CCustomCSSFile.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("c_customCSSFile")
			}
			return err
		}
	}

	return nil
}

func (m *ContentAsset) validateCreationDate(formats strfmt.Registry) error {

	if swag.IsZero(m.CreationDate) { // not required
		return nil
	}

	if err := validate.FormatOf("creation_date", "body", "date-time", m.CreationDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ContentAsset) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	if err := validate.MinLength("id", "body", string(*m.ID), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("id", "body", string(*m.ID), 256); err != nil {
		return err
	}

	return nil
}

func (m *ContentAsset) validateLastModified(formats strfmt.Registry) error {

	if swag.IsZero(m.LastModified) { // not required
		return nil
	}

	if err := validate.FormatOf("last_modified", "body", "date-time", m.LastModified.String(), formats); err != nil {
		return err
	}

	return nil
}

// additional properties value enum
var contentAssetSiteMapChangeFrequencyValueEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["always","hourly","daily","weekly","monthly","yearly","never"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		contentAssetSiteMapChangeFrequencyValueEnum = append(contentAssetSiteMapChangeFrequencyValueEnum, v)
	}
}

func (m *ContentAsset) validateSiteMapChangeFrequencyValueEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, contentAssetSiteMapChangeFrequencyValueEnum); err != nil {
		return err
	}
	return nil
}

func (m *ContentAsset) validateSiteMapChangeFrequency(formats strfmt.Registry) error {

	if swag.IsZero(m.SiteMapChangeFrequency) { // not required
		return nil
	}

	for k := range m.SiteMapChangeFrequency {

		// value enum
		if err := m.validateSiteMapChangeFrequencyValueEnum("site_map_change_frequency"+"."+k, "body", m.SiteMapChangeFrequency[k]); err != nil {
			return err
		}

	}

	return nil
}

// additional properties value enum
var contentAssetSiteMapIncludedValueEnum []interface{}

func init() {
	var res []int32
	if err := json.Unmarshal([]byte(`[1,0]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		contentAssetSiteMapIncludedValueEnum = append(contentAssetSiteMapIncludedValueEnum, v)
	}
}

func (m *ContentAsset) validateSiteMapIncludedValueEnum(path, location string, value int32) error {
	if err := validate.Enum(path, location, value, contentAssetSiteMapIncludedValueEnum); err != nil {
		return err
	}
	return nil
}

func (m *ContentAsset) validateSiteMapIncluded(formats strfmt.Registry) error {

	if swag.IsZero(m.SiteMapIncluded) { // not required
		return nil
	}

	for k := range m.SiteMapIncluded {

		if swag.IsZero(m.SiteMapIncluded[k]) { // not required
			continue
		}

		if err := validate.MinimumInt("site_map_included"+"."+k, "body", int64(*m.SiteMapIncluded[k]), 0, false); err != nil {
			return err
		}

		if err := validate.MaximumInt("site_map_included"+"."+k, "body", int64(*m.SiteMapIncluded[k]), 1, false); err != nil {
			return err
		}

		// value enum
		if err := m.validateSiteMapIncludedValueEnum("site_map_included"+"."+k, "body", *m.SiteMapIncluded[k]); err != nil {
			return err
		}

	}

	return nil
}

func (m *ContentAsset) validateSiteMapPriority(formats strfmt.Registry) error {

	if swag.IsZero(m.SiteMapPriority) { // not required
		return nil
	}

	for k := range m.SiteMapPriority {

		if err := validate.Maximum("site_map_priority"+"."+k, "body", float64(m.SiteMapPriority[k]), 1, false); err != nil {
			return err
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ContentAsset) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ContentAsset) UnmarshalBinary(b []byte) error {
	var res ContentAsset
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
